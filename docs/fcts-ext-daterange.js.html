<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>fcts-ext-daterange.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DateRange.html">DateRange</a><ul class='methods'><li data-type='method'><a href="DateRange.html#getConfig">getConfig</a></li><li data-type='method'><a href="DateRange.html#init">init</a></li><li data-type='method'><a href="DateRange.html#setConfig">setConfig</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">fcts-ext-daterange.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
module.exports = function (dep) {
  /**
   * Class representing the DateRange.
   */
  class DateRange {
    constructor () {
      /**
       * @private
       */
      this.startDt = 0;
      this.endDt = 0;
      this.startDataset = 0;
      this.endDataset = 0;
      this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');
      this.DateTimeFormatter = dep.DateTimeFormatter;
      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
      this.ComponentGroup = this.toolbox.ComponentGroup;
      this.SymbolStore = this.toolbox.SymbolStore;
      this.isDrawn = false;
    }

    /**
     * An object representing the start and end dates.
     * @type {DateRange.range}
     */
    get startDate () {
      return this.startDt;
    }

    set startDate (startDt) {
      let startTimestamp = this.getTimestamp(startDt),
        absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],
        minDiff = this.minActiveInterval,
        actualDiff = this.endDt - startTimestamp;
      if (startTimestamp &lt;= this.endDt &amp;&amp; startTimestamp >= absoluteStart &amp;&amp; actualDiff > minDiff) {
        this.startDt = startTimestamp;
        this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;
      } else {
        this.fromDate.updateVisual('errored');
      }
    }

    get endDate () {
      return this.endDt;
    }

    set endDate (endDt) {
      let endTimestamp = this.getTimestamp(endDt),
        absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],
        minDiff = this.minActiveInterval,
        actualDiff = endTimestamp - this.startDt;
      if (endTimestamp >= this.startDt &amp;&amp; endTimestamp &lt;= absoluteEnd &amp;&amp; actualDiff > minDiff) {
        this.endDt = endTimestamp;
        this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;
      } else {
        this.toDate.updateVisual('errored');
      }
    }

    getTimestamp (dateStr) {
      let dateFormat = this.config.dateFormat,
        dateFormatter = new dep.DateTimeFormatter(dateFormat);
      return +dateFormatter.getNativeDate(dateStr);
    }

    getDate (timestamp) {
      var dateFormat = this.config.dateFormat;
      return this.DateTimeFormatter.formatAs(timestamp, dateFormat);
    }

    /**
     * Sets the configurable options of the extension (e.g. cosmetics)
     * @param {Object} configObj The configuration object containing various extension options
     */
    setConfig (configObj) {}

    /**
     * Gets the configurable options of the extension (e.g. cosmetics)
     * @return {object} configObj The configuration object containing various extension options
     */
    getConfig () {
      return {
        calendarVisible: 'false'
      };
    }

    createExtData (extData) {
      let config = {};
      config.disabled = extData.disabled || 'false';
      config.layout = extData.layout || 'inline';
      config.orientation = extData.orientation || 'horizontal';
      config.position = extData.position || 'top';
      config.alignment = extData.alignment || 'right';
      config.dateFormat = extData.dateFormat || '%d-%m-%Y';
      config.fromText = extData.fromText || 'From:';
      config.toText = extData.toText || 'To:';
      config.styles = extData.styles || {
        'width': 120,
        'height': 22,

        'font-family': '"Lucida Grande", sans-serif',
        'font-size': 13,
        'font-color': '#4B4B4B',

        'input-fill': '#FFFFFF',
        'input-border-thickness': 1,
        'input-border-color': '#CED5D4',
        'input-border-radius': 1,

        'input-focus-fill': '#FFFFFF',
        'input-focus-border-thickness': 1,
        'input-focus-border-color': '#1E1F1F',

        'input-error-fill': '#FFEFEF',
        'input-error-border-thickness': 1,
        'input-error-border-color': '#D25353'
      };
      return config;
    }

    /**
     * Fusioncharts life cycle method for extension
     */
    init (require) {
      var instance = this;
      require([
        'xAxis',
        'graphics',
        'chart',
        'dataset',
        'globalReactiveModel',
        'spaceManagerInstance',
        'extData',
        'smartLabel',
        'chartInstance',
        function (
          xAxis,
          graphics,
          chart,
          dataset,
          globalReactiveModel,
          spaceManagerInstance,
          extData,
          smartLabel,
          chartInstance) {
          instance.xAxis = xAxis;
          instance.graphics = graphics;
          instance.chart = chart;
          instance.dataset = dataset;
          instance.globalReactiveModel = globalReactiveModel;
          instance.spaceManagerInstance = spaceManagerInstance;
          instance.config = instance.createExtData(extData);
          instance.smartLabel = smartLabel;
          instance.chartInstance = chartInstance;
        }
      ]);
      instance.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
      instance.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
      instance.toolbars = [];
      instance.measurement = {};
      instance.toolbars.push(instance.createToolbar());
      return instance;
    };

    createToolbar () {
      var toolbar,
        self = this,
        fromDateLabel,
        toDateLabel,
        group,
        fromFormattedDate,
        toFormattedDate;

      self.fromDate = {};
      self.toDate = {};

      fromFormattedDate = this.getDate(this.startDt);
      toFormattedDate = this.getDate(this.endDt);
      toolbar = new this.HorizontalToolbar({
        paper: this.graphics.paper,
        chart: this.chart,
        smartLabel: this.smartLabel,
        chartContainer: this.graphics.container
      });

      toolbar.setConfig({
        'fill': '#FFFFFF',
        'borderThickness': 0
      });

      group = new this.toolbox.ComponentGroup({
        paper: this.graphics.paper,
        chart: this.chart,
        smartLabel: this.smartLabel,
        chartContainer: this.graphics.container
      });

      group.setConfig({
        'fill': '#FFFFFF',
        'borderThickness': 0
      });

      fromDateLabel = new this.toolbox.Label(
        this.config['fromText'], {
          smartLabel: this.smartLabel,
          paper: this.graphics.paper
        }, {
          text: {
            style: {
              'font-size': this.config.styles['font-size'],
              'font-family': this.config.styles['font-family'],
              'fill': this.config.styles['font-color']
            }
          }
        }
      );

      toDateLabel = new this.toolbox.Label(
        this.config['toText'], {
          smartLabel: this.smartLabel,
          paper: this.graphics.paper
        }, {
          text: {
            style: {
              'font-size': this.config.styles['font-size'],
              'font-family': this.config.styles['font-family'],
              'fill': this.config.styles['font-color']
            }
          }
        }
      );

      self.fromDate = new this.toolbox.InputTextBoxSymbol({
        width: this.config.styles['width'],
        height: this.config.styles['height']
      }, {
        paper: this.graphics.paper,
        chart: this.chart,
        smartLabel: this.smartLabel,
        chartContainer: this.graphics.container
      }, {
        'strokeWidth': this.config.styles['input-border-thickness'],
        'fill': this.config.styles['input-fill'],
        'stroke': this.config.styles['input-border-color'],
        'radius': this.config.styles['input-border-radius'],
        'btnTextStyle': {
          'font-family': this.config.styles['font-family'],
          'fontSize': this.config.styles['font-size']
        },
        'label': fromFormattedDate,
        'labelFill': this.config.styles['font-color']
      });

      self.fromDate.addCustomState('errored', {
        config: {
          hover: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          },
          normal: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          },
          pressed: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          }
        }
      });

      self.fromDate.setStateConfig({
        pressed: {
          config: {
            pressed: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            },
            normal: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            },
            hover: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            }
          }
        },
        enabled: {
          config: {
            pressed: {
              'fill': this.config.styles['input-fill'],
              'stroke-width': this.config.styles['input-border-thickness'],
              'stroke': this.config.styles['input-border-color']
            },
            normal: {
              'fill': this.config.styles['input-fill'],
              'stroke-width': this.config.styles['input-border-thickness'],
              'stroke': this.config.styles['input-border-color']
            },
            hover: {
              'fill': this.config.styles['input-fill'],
              'stroke-width': this.config.styles['input-border-thickness'],
              'stroke': this.config.styles['input-border-color']
            }
          }
        }
      });

      self.toDate = new this.toolbox.InputTextBoxSymbol({
        width: this.config.styles['width'],
        height: this.config.styles['height']
      }, {
        paper: this.graphics.paper,
        chart: this.chart,
        smartLabel: this.smartLabel,
        chartContainer: this.graphics.container
      }, {
        'strokeWidth': this.config.styles['input-border-thickness'],
        'fill': this.config.styles['input-fill'],
        'stroke': this.config.styles['input-border-color'],
        'radius': this.config.styles['input-border-radius'],
        'btnTextStyle': {
          'font-family': this.config.styles['font-family'],
          'fontSize': this.config.styles['font-size']
        },
        'label': toFormattedDate,
        'labelFill': this.config.styles['font-color']
      });

      self.toDate.addCustomState('errored', {
        config: {
          hover: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          },
          normal: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          },
          pressed: {
            'fill': this.config.styles['input-error-fill'],
            'stroke-width': this.config.styles['input-error-border-thickness'],
            'stroke': this.config.styles['input-error-border-color']
          }
        }
      });

      self.toDate.setStateConfig({
        pressed: {
          config: {
            pressed: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            },
            normal: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            },
            hover: {
              'fill': this.config.styles['input-focus-fill'],
              'stroke-width': this.config.styles['input-focus-border-thickness'],
              'stroke': this.config.styles['input-focus-border-color']
            }
          },
          enabled: {
            config: {
              pressed: {
                'fill': this.config.styles['input-fill'],
                'stroke-width': this.config.styles['input-border-thickness'],
                'stroke': this.config.styles['input-border-color']
              },
              normal: {
                'fill': this.config.styles['input-fill'],
                'stroke-width': this.config.styles['input-border-thickness'],
                'stroke': this.config.styles['input-border-color']
              },
              hover: {
                'fill': this.config.styles['input-fill'],
                'stroke-width': this.config.styles['input-border-thickness'],
                'stroke': this.config.styles['input-border-color']
              }
            }
          }
        }
      });

      self.fromDate.attachEventHandlers({
        click: {
          fn: () => {
            self.fromDate.edit();
            self.fromDate.updateVisual('pressed');
          }
        },
        keypress: (e) => {
          let event = e || window.event,
            charCode = event.which || event.keyCode;
          if (charCode === 13) {
            self.fromDate.blur();
            self.startDate = self.fromDate.getText();
            if (self.fromDate.state !== 'errored') {
              self.fromDate.updateVisual('enabled');
            }
          }
        },
        textOnBlur: function () {
          self.fromDate.blur();
          self.startDate = self.fromDate.getText();
          if (self.fromDate.state !== 'errored') {
            self.fromDate.updateVisual('enabled');
          }
        }
      });

      self.toDate.attachEventHandlers({
        click: {
          fn: () => {
            self.toDate.edit();
            self.toDate.updateVisual('pressed');
          }
        },
        keypress: (e) => {
          let event = e || window.event,
            charCode = event.which || event.keyCode;
          if (charCode === 13) {
            self.toDate.blur();
            self.endDate = self.toDate.getText();
            if (self.toDate.state !== 'errored') {
              self.toDate.updateVisual('enabled');
            }
          }
        },
        textOnBlur: function () {
          self.toDate.blur();
          self.endDate = self.toDate.getText();
          if (self.toDate.state !== 'errored') {
            self.toDate.updateVisual('enabled');
          }
        }
      });

      // Temporary. Required to render the text box correctly. Commenting this out distorts toolbox.
      this.SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
        var x1 = x - w / 2 + padX / 2,
          x2 = x + w / 2 - padX / 2,
          y1 = y - h / 2 + padY / 2,
          y2 = y + h / 2 - padY / 2;

        return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
      });

      group.addSymbol(fromDateLabel);
      group.addSymbol(self.fromDate);
      group.addSymbol(toDateLabel);
      group.addSymbol(self.toDate);
      toolbar.addComponent(group);
      return toolbar;
    };

    getLogicalSpace (availableWidth, availableHeight) {
      var logicalSpace,
        width = 0,
        height = 0,
        i,
        ln;

      availableWidth /= 2;

      for (i = 0, ln = this.toolbars.length; i &lt; ln; i++) {
        logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
        width = Math.max(logicalSpace.width, width);
        height += logicalSpace.height;
        this.toolbars[i].width = logicalSpace.width;
        this.toolbars[i].height = logicalSpace.height;
      }
      height += this.padding;
      return {
        width: width,
        height: height
      };
    };

    placeInCanvas () {
      var self = this;
      self.padding = 5;
      self.spaceManagerInstance.add([{
        name: function () {
          return 'DateRangeChooserToolbox';
        },
        ref: function (obj) {
          return obj['0'];
        },
        self: function () {
          return self;
        },
        priority: function () {
          return 2;
        },
        layout: function (obj) {
          return obj[self.config.layout];
        },
        orientation: [{
          type: function (obj) {
            return obj[self.config.orientation];
          },
          position: [{
            type: function (obj) {
              return obj[self.config.position];
            },
            alignment: [{
              type: function (obj) {
                return obj[self.config.alignment];
              },
              dimensions: [function () {
                var parent = this.getParentComponentGroup();
                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
              }]
            }]
          }]
        }]
      }]);
    };

    setDrawingConfiguration (x, y, width, height, group) {
      var mes = this.measurement;
      mes.x = x;
      mes.y = y;
      mes.width = width;
      mes.height = height;

      this.parentGroup = group;

      return this;
    };

    draw (x, y, width, height, group) {
      let self = this,
        measurement = self.measurement,
        toolbars = self.toolbars,
        ln,
        i,
        toolbar,
        model = self.globalReactiveModel;

      x = x === undefined ? measurement.x : x;
      y = y === undefined ? measurement.y : y;
      width = width === undefined ? measurement.width : width;
      height = height === undefined ? measurement.height : height;
      group = group === undefined ? self.parentGroup : group;
      if (width &amp;&amp; height) {
        self.isDrawn = true;
        for (i = 0, ln = toolbars.length; i &lt; ln; i++) {
          toolbar = toolbars[i];
          toolbar.draw(x, y, group);
        }
        model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'],
          (start, end) => {
            // self.fromDate.blur(new Date(start[1]).toLocaleDateString());
            // self.toDate.blur(new Date(end[1]).toLocaleDateString());
            self.startDt = start[1];
            self.fromDate.blur(self.getDate(start[1]));
            self.fromDate.updateVisual('enabled');
            self.endDt = end[1];
            self.toDate.blur(self.getDate(end[1]));
            self.fromDate.updateVisual('enabled');
          }
        );
      }
      self.startDataset = self.globalReactiveModel.model['x-axis-absolute-range-start'];
      self.endDataset = self.globalReactiveModel.model['x-axis-absolute-range-end'];
      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];
      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];
      self.minDatestampDiff = self.globalReactiveModel.model['minimum-consecutive-datestamp-diff'];
      self.minActiveInterval = self.maxXAxisTicks * self.minDatestampDiff;
    };
  }
  return DateRange;
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun Dec 04 2016 17:43:50 GMT+0530 (IST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
