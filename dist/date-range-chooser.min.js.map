{"version":3,"sources":["webpack:///webpack/bootstrap 9b890f686cecd618e5a6","webpack:///./src/index.js","webpack:///./src/fcts-ext-daterange.js"],"names":[],"mappings":"YACA,cAMA,MACA,eAGA,mBACA,CACA,cACA,EAIA,kDAGA,KAGA,YACA,OAIA,IAzBA,iBA4BA,MAGA,MAGA,0BCtCA,CACA,uBAEA,GAAC,cACD,uBACA,oBACA,yBACA,OACA,yBAEA,6CACA,KAEA,uBAEA,KAAC,qDACD,SACA,8EACA,kBACA,2EAAwE,aACxE,oBACA,IACA,GAAC,eCtBD,CACA,kCAIA,QACA,cAIA,iBACA,aACA,oBACA,kBACA,EACA,iFAEA,gCAEA,mCACA,2DAEA,uCAEA,yEACA,mDACA,oBACA,qCACA,2BACA,QACA,oBAMA,gBACA,aACA,OAEA,iBACA,yBACA,uBACA,0CACA,gEACA,oCACA,+BACA,MACA,EAYA,4DACA,+BAGA,gCAfA,6CACA,oCACA,sBACA,oEAGA,iCACA,+BAGA,UAOA,yBACA,aAGA,UACA,qBACA,0CACA,kCACA,4CACA,4CAIA,uCAEA,cACA,aACA,KAEA,eACA,yBACA,uBACA,wCACA,gEACA,oCACA,2BAEA,YACA,EAYA,wDACA,6BAGA,gCAfA,4CACA,kCACA,kBACA,kEAGA,6BACA,6BAGA,UAOA,wBACA,aAGA,UACA,mBACA,0CACA,kCACA,iDACA,wCAIA,4CAEA,mBACA,iBAGA,mCACA,mBACA,0CACA,kCACA,+BACA,2CACS,uBACT,uCAIA,0BAEA,yBACA,YAGA,oCACA,mBACA,0CACA,kCACA,gCACA,2CACS,wBACT,uCAIA,2BAEA,gBACA,mBACA,qCACA,0BACA,EAEA,WACA,mBACA,oDACA,EAMA,aAMA,YACA,OACA,iBAEA,QAEA,gBACA,IACA,0BA6DA,gCACA,sCACA,oCACA,+BACA,mCACA,kCACA,6CACA,+BACA,uCACA,iCApEA,aACA,OACA,WACA,UACA,UACA,MACA,SAEA,cACA,+BACA,OACA,MACA,yBACA,SAKA,iBACA,OACA,eACA,0CACA,YAGA,mBACA,UACA,WACA,8CACA,OACA,MACA,iBAIA,qBACA,WACA,6CACA,OACA,MACA,iBAOA,qBACA,WACA,gCACA,OACA,eACA,0CACA,YAKA,gBAWA,QACA,CAEA,mBA2HA,CAEA,cAwBA,CAEA,qBACA,CACA,4DACA,CACA,gBACA,4BAGA,2DAEA,eAA6B,cAA0B,OACvD,mBAEA,GACA,oBAEA,0CACA,YAKA,UACA,EAEA,EAKA,QACA,OACA,cACA,CACA,QACA,WACA,QACA,UACA,sBACA,uBACA,UACA,aACA,gBACA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,SACA,aACA,UACA,YACA,wBACA,yBACA,0BACA,gBACA,kBACA,CAEA,0CACA,kEACA,8BACA,cACA,iCACA,iBACA,CAEA,gBACA,IACA,GAEA,EACA,EACA,EACA,EAoJA,EAEA,IA1JA,mBAKA,WACA,4BACA,yBACA,kBACA,OACA,UACA,OACA,GAEA,cADA,8CAGA,OACA,uCACA,oBACA,gCACA,wCAGA,eACA,6CAGA,aACA,IAoCA,qBACA,iBACA,sBACA,wCAEA,oBAsFA,cAEA,8BACA,6BACA,oCAEA,qCAEA,qCAEA,KACA,eACA,WACA,uBACA,mBACA,UAIA,+BACA,YAEA,eACA,WACA,qBACA,mBACA,UAIA,+BACA,YAIA,MACA,UACA,MACA,SACA,SACA,eACA,iBACA,iBACA,mBACA,iBACA,4BACA,mCAGA,YACA,eAvIA,iBAMA,qBACA,WAEA,cACA,iBACA,mBACA,QACA,gCACA,OACA,yCAWA,OACA,iBACA,wBACA,OACA,0CAGA,8BAKA,YAEA,SAiGA,UACA,MACA,SACA,SACA,eACA,iBACA,iBACA,mBACA,iBACA,4BACA,mCAGA,YACA,eA9GA,iBAOA,mBACA,WAEA,cACA,iBACA,mBACA,QACA,4BACA,OACA,sCAGA,4BAMA,aACA,iBAEA,oBACA,OAIA,iDAKA,WAEA,SA0EA,eA/KA,WAEA,UACA,OACA,OACA,SACA,oCAGA,yDACA,4BAEA,GACA,EAmKA,cArMA,eAEA,aACA,cACA,OACA,SACA,uCACA,kBACA,oCACA,iEACA,OACA,OACA,oDACA,aAGA,+BACA,oCACA,GACA,CACA,EAmLA,kBACA,kBACA,GACA,CAEA,qBACA,0CACA,mCACA,gCACA,OACA,SACA,eAEA,OAEA,gBACA,OACA,iCACA,gBACA,OACA,yBACA,iBACA,OACA,KACA,iBACA,OACA,EACA,qBACA,OACA,EACA,oBACA,mBACA,OACA,eACA,iBACA,mBACA,YACA,YACA,iBACA,mBACA,SACA,aACA,iBACA,mBACA,UACA,wBACA,YACA,kEACA,YAKA,WAEA,mCACA,YACA,uBACA,MACA,UACA,WAEA,mBAEA,EACA,IAEA,gBACA,IAIA,GACA,EACA,IALA,SACA,gBACA,aAKA,wCACA,mBACA,uBACA,wBACA,6BACA,OACA,OACA,mBAAyC,SAAQ,EACjD,QACA,cAEA,KACA,+EAEA,aACA,+BAKA,4BACA,mCACA,qBACA,6BAKA,0BACA,iCAEA,UAEA,EAEA,CACA,oEACA,uCACO,SACP,uEACA,yCAEA,oDACA,wEACA,yEACA,4EACA,+EACA,4EACA,uFACA,kFACA,YAEA,QACA","file":"date-range-chooser.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9b890f686cecd618e5a6","'use strict';\nconst DateRange = require('./fcts-ext-daterange');\n\n;(function (env, factory) {\n  if (typeof module === 'object' && module.exports) {\n    module.exports = env.document\n       ? factory(env) : function (win) {\n         if (!win.document) {\n           throw new Error('Window with document not present');\n         }\n         return factory(win, true);\n       };\n  } else {\n    env.DateRangeChooser = factory(env, true);\n  }\n})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {\n  var FC = _window.FusionCharts;\n  FC.register('extension', ['private', 'date-range-chooser', function () {\n    var DateTimeFormatter = this.hcLib.DateTimeFormatter;\n    FC.registerComponent('extensions', 'date-range-chooser', DateRange({FusionCharts: FC,\n      DateTimeFormatter: DateTimeFormatter}));\n  }]);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","'use strict';\nmodule.exports = function (dep) {\n  /**\n   * Class representing the DateRange.\n   */\n  class DateRange {\n    constructor () {\n      /**\n      * @private\n      */\n      this.startDt = 0;\n      this.endDt = 0;\n      this.startDataset = 0;\n      this.endDataset = 0;\n      if (typeof dep.FusionCharts === 'function') {\n        this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');\n      } else {\n        throw new Error('Unable to find FusionCharts.');\n      }\n      if (typeof dep.FusionCharts === 'function') {\n        this.DateTimeFormatter = dep.DateTimeFormatter;\n      } else {\n        throw new Error('Unable to find DateTimeFormatter.');\n      }\n      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;\n      this.ComponentGroup = this.toolbox.ComponentGroup;\n      this.isDrawn = false;\n      this.startTooltipErrorMsg = '';\n      this.endTooltipErrorMsg = '';\n      this.createObjectAssign();\n    }\n\n    /**\n     * An object representing the start and end dates.\n     * @type {DateRange.range}\n     */\n    get startDate () {\n      return this.startDt;\n    }\n\n    set startDate (startDt) {\n      let startTimestamp = this.getTimestamp(startDt),\n        newDate = this.getDate(this.startDt),\n        absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n        absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n        minDiff = this.minActiveInterval,\n        actualDiff = this.endDt - startTimestamp;\n      if (newDate !== startDt) {\n        if (this.isBetween(startTimestamp, absoluteStart, absoluteEnd, 'from') &&\n          this.isBeforeOrEqualTo(startTimestamp, this.endDt, 'from') &&\n          this.diffIsGreaterThan(actualDiff, minDiff, 'from')) {\n          this.startDt = startTimestamp;\n          this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;\n        } else {\n          // this.toError.group.hide();\n          this.fromDate.setState('errored');\n          this.fromDate.state = 'errored';\n        }\n      } else {\n        if (this.fromDate.state === 'errored') {\n          this.fromDate.removeState('errored');\n          this.fromDate.state = 'enabled';\n        }\n      }\n    }\n\n    isBeforeOrEqualTo (startTimestamp, endTimestamp, errorType) {\n      if (startTimestamp <= endTimestamp) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date must be less than end date!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Date must be less than end date!');\n        }\n        return false;\n      }\n    }\n\n    get endDate () {\n      return this.endDt;\n    }\n\n    set endDate (endDt) {\n      let endTimestamp = this.getTimestamp(endDt),\n        newDate = this.getDate(this.endDt),\n        absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n        absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n        minDiff = this.minActiveInterval,\n        actualDiff = endTimestamp - this.startDt;\n\n      if (newDate !== endDt) {\n        if (this.isBetween(endTimestamp, absoluteStart, absoluteEnd, 'to') &&\n          this.isAfterOrEqualTo(endTimestamp, this.startDt, 'to') &&\n          this.diffIsGreaterThan(actualDiff, minDiff, 'to')) {\n          this.endDt = endTimestamp;\n          this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;\n        } else {\n          // this.fromError.group.hide();\n          this.toDate.setState('errored');\n          this.toDate.state = 'errored';\n        }\n      } else {\n        if (this.toDate.state === 'errored') {\n          this.toDate.removeState('errored');\n          this.toDate.state = 'enabled';\n        }\n      }\n    }\n\n    isAfterOrEqualTo (endTimestamp, startTimestamp, errorType) {\n      if (endTimestamp >= startTimestamp) {\n        return true;\n      } else {\n        this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date must be greater than start date!</span>';\n        if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Date must be greater than start date!');\n        }\n        return false;\n      }\n    }\n\n    isBetween (timestamp, absoluteStart, absoluteEnd, errorType) {\n      if (timestamp >= absoluteStart && timestamp <= absoluteEnd) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg = this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date out of bounds!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Date out of bounds!');\n        } else if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Date out of bounds!');\n        }\n        return false;\n      }\n    }\n\n    diffIsGreaterThan (actualDiff, minDiff, errorType) {\n      if (actualDiff > minDiff) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg = this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Zoom limit exceeded!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Zoom limit exceeded!');\n        } else if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Zoom limit exceeded!');\n        }\n        return false;\n      }\n    }\n\n    getTimestamp (dateStr) {\n      let dateFormat = this.config.dateFormat,\n        dateFormatter = new dep.DateTimeFormatter(dateFormat);\n      return +dateFormatter.getNativeDate(dateStr);\n    }\n\n    getDate (timestamp) {\n      var dateFormat = this.config.dateFormat;\n      return this.DateTimeFormatter.formatAs(timestamp, dateFormat);\n    }\n\n    /**\n     * Sets the configurable options of the extension (e.g. cosmetics)\n     * @param {Object} configObj The configuration object containing various extension options\n     */\n    setConfig (configObj) {}\n\n    /**\n     * Gets the configurable options of the extension (e.g. cosmetics)\n     * @return {object} configObj The configuration object containing various extension options\n     */\n    getConfig () {\n      return {\n        calendarVisible: 'false'\n      };\n    }\n\n    createConfig (extData) {\n      let config = {},\n        defaultStyles = {\n\n          inputButton: {\n            'width': 120,\n            'height': 22,\n            radius: 1,\n            padding: {\n              left: 15,\n              right: 10\n            },\n            className: 'date-range-chooser',\n            container: {\n              style: {\n                fill: '#FFFFFF',\n                'stroke-width': 1,\n                stroke: '#CED5D4'\n                // 'input-shadow-fill': '#000000',\n                // 'input-shadow-opacity': 0.35,\n              }\n            },\n            text: {\n              style: {\n                'font-family': '\"Lucida Grande\", sans-serif',\n                'font-size': '13px',\n                fill: '#4B4B4B'\n              }\n            },\n            states: {\n              selected: {\n                className: 'date-range-chooser-state-selected',\n                container: {\n                  style: {\n                    fill: '#FFFFFF',\n                    stroke: '#1E1F1F'\n                  }\n                }\n              },\n              errored: {\n                className: 'date-range-chooser-state-errored',\n                container: {\n                  style: {\n                    fill: '#FFFFFF',\n                    stroke: '#D25353'\n                  }\n                }\n                // 'input-error-tooltip-font-color': '#FF0000'\n              }\n            }\n          },\n          label: {\n            className: 'date-range-chooser-label',\n            text: {\n              style: {\n                'font-family': '\"Lucida Grande\", sans-serif',\n                'font-size': '13px',\n                fill: '#4B4B4B'\n              }\n            }\n          }\n        };\n      config.disabled = extData.disabled || false;\n      config.layout = extData.layout || 'inline';\n      config.orientation = extData.orientation || 'horizontal';\n      config.position = extData.position || 'top';\n      config.alignment = extData.alignment || 'right';\n      config.dateFormat = extData.dateFormat || '%d-%m-%Y';\n      config.fromText = extData.fromText || 'From:';\n      config.fromTooltipText = extData.fromTooltipText || 'From Date';\n      config.toText = extData.toText || 'To:';\n      config.toTooltipText = extData.toTooltipText || 'To Date';\n      config.styles = Object.assign(defaultStyles, extData.styles);\n      return config;\n    }\n\n    createErrorGroup (symbol) {\n      // return;\n    //   let self = this,\n    //     paper = self.graphics.paper,\n    //     circle,\n    //     crossPath,\n    //     cross,\n    //     rect,\n    //     text,\n    //     group,\n    //     textBBox,\n    //     circleBBox,\n    //     rectBBox,\n    //     symbolBBox,\n    //     orientation = self.config.orientation,\n    //     position = self.config.position;\n\n    //   if (orientation === 'horizontal') {\n    //     if (position === 'top') {\n    //       symbolBBox = symbol.getBoundElement().getBBox();\n    //       group = paper.group('error-group');\n\n    //       rect = paper.rect(symbolBBox.x,\n    //         symbolBBox.y - symbolBBox.height, 20, 20, group);\n    //       rectBBox = rect.getBBox();\n\n    //       circle = paper.circle(rectBBox.x + 5 + 1,\n    //         rectBBox.y + 6 + 4, 6, group);\n    //       circleBBox = circle.getBBox();\n\n    //       crossPath = this.getCrossPath(circleBBox, 4);\n    //       cross = paper.path(crossPath, group);\n\n    //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //         '', group);\n    //       textBBox = text.getBBox();\n    //     } else if (position === 'bottom') {\n    //       symbolBBox = symbol.getBoundElement().getBBox();\n    //       group = paper.group('error-group');\n\n    //       rect = paper.rect(symbolBBox.x,\n    //         symbolBBox.y + symbolBBox.height, 20, 20, group);\n    //       rectBBox = rect.getBBox();\n\n    //       circle = paper.circle(rectBBox.x + 5 + 1,\n    //         rectBBox.y + 6 + 4, 6, group);\n    //       circleBBox = circle.getBBox();\n\n    //       crossPath = this.getCrossPath(circleBBox, 4);\n    //       cross = paper.path(crossPath, group);\n\n    //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //         '', group);\n    //       textBBox = text.getBBox();\n    //     }\n    //   } else if (orientation === 'vertical') {\n    //     symbolBBox = symbol.getBoundElement().getBBox();\n    //     group = paper.group('error-group');\n\n    //     rect = paper.rect(symbolBBox.x,\n    //       symbolBBox.y + symbolBBox.height, 20, 20, group);\n    //     rectBBox = rect.getBBox();\n\n    //     circle = paper.circle(rectBBox.x + 5 + 1,\n    //       rectBBox.y + 6 + 4, 6, group);\n    //     circleBBox = circle.getBBox();\n\n    //     crossPath = this.getCrossPath(circleBBox, 4);\n    //     cross = paper.path(crossPath, group);\n\n    //     text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //       '', group);\n    //     textBBox = text.getBBox();\n    //   }\n\n    //   circle.attr({\n    //     'stroke': '#d71f26',\n    //     'stroke-width': '1',\n    //     'fill': 'none'\n    //   });\n    //   cross.attr({\n    //     'stroke': '#000000',\n    //     'stroke-width': '1.5'\n    //   });\n    //   text.attr({\n    //     'text-anchor': 'start',\n    //     'y': textBBox.y + textBBox.height,\n    //     'fill': '#D80000',\n    //     'font-family': '\"Lucida Grande\", sans-serif',\n    //     'font-size': '12'\n    //   });\n    //   rect.attr({\n    //     'fill': '#FFFFFF',\n    //     'fill-opacity': '0.8',\n    //     'stroke-width': '0',\n    //     'width': textBBox.width + circleBBox.width\n    //   });\n    //   group.attr({\n    //     visibility: 'hidden'\n    //   });\n\n    //   return {\n    //     'group': group,\n    //     'cross': cross,\n    //     'circle': circle,\n    //     'rect': rect,\n    //     'text': text\n    //   };\n    // }\n\n    // getCrossPath (circleBox, padding) {\n    //   // M478,77L483,82M478,82L483,77\n    //   let circleX1 = Math.round(circleBox.x),\n    //     circleY1 = Math.round(circleBox.y),\n    //     circleX2 = Math.round(circleBox.x2),\n    //     circleY2 = Math.round(circleBox.y2),\n    //     crossX1 = circleX1 + 4,\n    //     crossY1 = circleY1 + 2,\n    //     crossX2 = circleX2 - 4,\n    //     crossY2 = circleY2 - 3,\n    //     pathStr = 'M' + crossX1 + ',' + crossY1 + 'L' + crossX2 + ',' + crossY2;\n    //   pathStr += 'M' + crossX1 + ',' + crossY2 + 'L' + crossX2 + ',' + crossY1;\n    //   return pathStr;\n    }\n\n    setErrorMsg (errorGroup, errorMsg) {\n      // return;\n      // let errorRectX,\n      //   errorRectWidth,\n      //   errorRectEnd;\n\n      // if (errorGroup.text.attr('text') === errorMsg) {\n      //   return;\n      // }\n      // errorGroup.text.attr('text', errorMsg);\n      // errorGroup.rect.attr('width',\n      //   errorGroup.text.getBBox().width + (4 * 2) + errorGroup.circle.getBBox().width + 2);\n\n      // errorRectX = errorGroup.rect.getBBox().x;\n      // errorRectWidth = errorGroup.rect.getBBox().width;\n      // errorRectEnd = errorRectX + errorRectWidth;\n      // console.log(errorRectEnd, this.containerRight);\n      // if (errorRectEnd > this.containerRight) {\n      //   let diff = errorRectEnd - this.containerRight;\n      //   errorGroup.rect.attr('x', errorRectX - diff);\n      //   errorGroup.circle.attr('cx', errorGroup.circle.getBBox().x - diff + 5);\n      //   errorGroup.cross.translate(-diff - 1, 0);\n      //   errorGroup.text.attr('x', errorGroup.text.getBBox().x - diff);\n      // }\n    }\n\n    createObjectAssign () {\n      if (typeof Object.assign !== 'function') {\n        Object.assign = function (target, varArgs) {\n          'use strict';\n          if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n          }\n\n          var to = Object(target);\n\n          for (let index = 1; index < arguments.length; index++) {\n            let nextSource = arguments[index];\n\n            if (nextSource != null) {\n              for (let nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                  to[nextKey] = nextSource[nextKey];\n                }\n              }\n            }\n          }\n          return to;\n        };\n      }\n    }\n\n    /**\n     * Fusioncharts life cycle method for extension\n     */\n    init (require) {\n      var instance = this;\n      require([\n        'xAxis',\n        'graphics',\n        'chart',\n        'dataset',\n        'globalReactiveModel',\n        'spaceManagerInstance',\n        'extData',\n        'smartLabel',\n        'chartInstance',\n        function (\n          xAxis,\n          graphics,\n          chart,\n          dataset,\n          globalReactiveModel,\n          spaceManagerInstance,\n          extData,\n          smartLabel,\n          chartInstance) {\n          instance.xAxis = xAxis;\n          instance.graphics = graphics;\n          instance.chart = chart;\n          instance.dataset = dataset;\n          instance.globalReactiveModel = globalReactiveModel;\n          instance.spaceManagerInstance = spaceManagerInstance;\n          instance.config = instance.createConfig(extData);\n          instance.smartLabel = smartLabel;\n          instance.chartInstance = chartInstance;\n        }\n      ]);\n      instance.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];\n      instance.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];\n      instance.toolbars = [];\n      instance.measurement = {};\n      instance.toolbars.push(instance.createToolbar());\n      return instance;\n    };\n\n    createToolbar () {\n      var toolbar,\n        self = this,\n        fromGroup,\n        toGroup,\n        fromFormattedDate,\n        toFormattedDate,\n        styles = this.config.styles,\n        inputBtnStyles = styles.inputButton,\n        paper = this.graphics.paper,\n        d3 = paper.getInstances().d3,\n        addCssRules = function (classNames, styles) {\n          var key, className;\n          for (key in classNames) {\n            className = classNames[key];\n            switch (key) {\n              case 'container':\n                styles.container && paper.cssAddRule('.' + className, styles.container.style);\n                break;\n              case 'input':\n                styles.text && paper.cssAddRule('.' + className, {\n                  color: styles.text.style.fill,\n                  'font-family': styles.text.style['font-family'],\n                  'font-size': styles.text.style['font-size']\n                });\n                break;\n              case 'text':\n                styles.text && paper.cssAddRule('.' + className, styles.text.style);\n            }\n          }\n        },\n        createInputButtons = function (store) {\n          var key, inputButton, text, config, states, state;\n\n          for (key in store) {\n            inputButton = store[key];\n            text = inputButton.text;\n            config = inputButton.config;\n            self[key] = d3.inputButton(text).setConfig(config);\n            self[key].namespace('fusioncharts');\n            self[key].appendSelector('daterange');\n            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), inputBtnStyles);\n            states = config.states;\n            for (state in states) {\n              addCssRules(self[key].getIndividualClassNames(self[key].config.states[state]),\n                inputBtnStyles.states[state]);\n            }\n\n            self[key].attachEventHandlers(inputButton.eventListeners);\n            inputButton.group.addSymbol(self[key]);\n          }\n        },\n        createLabels = function (store) {\n          var key, label, text, config;\n\n          for (key in store) {\n            label = store[key];\n            text = label.text;\n            config = label.config;\n            self[key] = new self.toolbox.Label(text, dependencies, config);\n            // self[key].namespace('fusioncharts');\n            // self[key].appendSelector('daterange');\n            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), label.styles);\n            label.group.addSymbol(self[key]);\n          }\n        },\n        dependencies = {\n          paper: this.graphics.paper,\n          chart: this.chart,\n          smartLabel: this.smartLabel,\n          chartContainer: this.graphics.container\n        },\n        fromDateEventConfig = {\n          click: function () {\n              // if (self.fromDate.state === 'errored' &&\n              //   self.fromError.text.attr('text') !== '') {\n              //   self.toError.group.hide();\n              //   self.fromError.group.show();\n              // }\n            self.fromDate.setState('selected');\n          },\n          // tooltext: self.config.fromTooltipText,\n          keypress: (e) => {\n            let event = e || window.event,\n              charCode = event.which || event.keyCode;\n            if (charCode === 13) {\n              self.startDate = self.fromDate.text();\n              if (self.fromDate.state !== 'errored') {\n                self.fromDate.blur();\n                // self.fromError.group.hide();\n                // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n                // self.fromDate.removeState('selected');\n                // self.fromDate.removeState('errored');\n              } else {\n                // self.fromError.group.show();\n                // self.fromDate.state = 'errored';\n                // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n              }\n            }\n          },\n          blur: function () {\n            self.startDate = self.fromDate.text();\n            if (self.fromDate.state !== 'errored') {\n              self.fromDate.blur();\n              // self.fromError.group.hide();\n              // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n              self.fromDate.removeState('selected');\n            } else {\n              // self.fromError.group.show();\n              // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n            }\n          }\n        },\n        toDateEventConfig = {\n          click: function () {\n              // if (self.toDate.state === 'errored' &&\n              //   self.toError.text.attr('text') !== '') {\n              //   self.fromError.group.hide();\n              //   self.toError.group.show();\n              // }\n              // self.toDate.edit();\n            self.toDate.setState('selected');\n          },\n          // tooltext: self.config.toTooltipText,\n          keypress: (e) => {\n            let event = e || window.event,\n              charCode = event.which || event.keyCode;\n            if (charCode === 13) {\n              self.endDate = self.toDate.text();\n              if (self.toDate.state !== 'errored') {\n                self.toDate.blur();\n                // self.toError.group.hide();\n                // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n                self.toDate.removeState('selected');\n              } else {\n                // self.toError.group.show();\n                // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n              }\n            }\n          },\n          blur: function () {\n            // self.toDate.blur();\n            self.endDate = self.toDate.text();\n            if (self.toDate.state !== 'errored') {\n              // self.toDate.blur();\n              // self.toError.group.hide();\n              // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n              self.toDate.removeState('selected');\n            } else {\n              // self.toError.group.show();\n              // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n            }\n          }\n        },\n        labelList,\n        inputButtonlist;\n\n      self.fromDate = {};\n      self.toDate = {};\n\n      fromFormattedDate = this.getDate(this.startDt);\n      toFormattedDate = this.getDate(this.endDt);\n      toolbar = new this.HorizontalToolbar(dependencies);\n\n      fromGroup = new this.toolbox.ComponentGroup(dependencies);\n\n      toGroup = new this.toolbox.ComponentGroup(dependencies);\n\n      labelList = {\n        fromDateLabel: {\n          text: this.config['fromText'],\n          config: {\n            className: styles.label.className,\n            container: {\n              'width': 40\n            }\n          },\n          styles: styles.label,\n          group: fromGroup\n        },\n        toDateLabel: {\n          text: this.config['toText'],\n          config: {\n            className: styles.label.className,\n            container: {\n              'width': 40\n            }\n          },\n          styles: styles.label,\n          group: toGroup\n        }\n      };\n\n      inputButtonlist = {\n        fromDate: {\n          text: fromFormattedDate,\n          config: {\n            width: inputBtnStyles.width,\n            height: inputBtnStyles.height,\n            padding: inputBtnStyles.padding,\n            radius: inputBtnStyles.radius,\n            className: inputBtnStyles.className,\n            states: {\n              selected: inputBtnStyles.states.selected.className,\n              errored: inputBtnStyles.states.errored.className\n            }\n          },\n          eventListeners: fromDateEventConfig,\n          group: fromGroup\n        },\n        toDate: {\n          text: toFormattedDate,\n          config: {\n            width: inputBtnStyles.width,\n            height: inputBtnStyles.height,\n            padding: inputBtnStyles.padding,\n            radius: inputBtnStyles.radius,\n            className: inputBtnStyles.className,\n            states: {\n              selected: inputBtnStyles.states.selected.className,\n              errored: inputBtnStyles.states.errored.className\n            }\n          },\n          eventListeners: toDateEventConfig,\n          group: toGroup\n        }\n      };\n\n      createLabels(labelList);\n      createInputButtons(inputButtonlist);\n\n      toolbar.addComponent(fromGroup);\n      toolbar.addComponent(toGroup);\n      return toolbar;\n    };\n\n    getLogicalSpace (availableWidth, availableHeight) {\n      var logicalSpace = this.toolbars[0].getLogicalSpace(availableWidth, availableHeight);\n      this.toolbars[0].width = logicalSpace.width;\n      this.toolbars[0].height = logicalSpace.height;\n      return {\n        width: logicalSpace.width,\n        height: logicalSpace.height\n      };\n    };\n\n    placeInCanvas () {\n      var self = this;\n      self.spaceManagerInstance.add([{\n        name: function () {\n          return 'DateRangeChooserToolbox';\n        },\n        ref: function (obj) {\n          return obj['0'];\n        },\n        self: function () {\n          return self;\n        },\n        priority: function () {\n          return 2;\n        },\n        layout: function (obj) {\n          return obj[self.config.layout];\n        },\n        orientation: [{\n          type: function (obj) {\n            return obj[self.config.orientation];\n          },\n          position: [{\n            type: function (obj) {\n              return obj[self.config.position];\n            },\n            alignment: [{\n              type: function (obj) {\n                return obj[self.config.alignment];\n              },\n              dimensions: [function () {\n                var parent = this.getParentComponentGroup();\n                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());\n              }]\n            }]\n          }]\n        }]\n      }]);\n    };\n\n    setDrawingConfiguration (x, y, width, height, group) {\n      var mes = this.measurement;\n      mes.x = x;\n      mes.y = y;\n      mes.width = width;\n      mes.height = height;\n\n      this.parentGroup = group;\n\n      return this;\n    };\n\n    draw (x, y, width, height, group) {\n      let self = this,\n        measurement = self.measurement,\n        toolbars = self.toolbars,\n        ln,\n        i,\n        toolbar,\n        model = self.globalReactiveModel;\n\n      x = x === undefined ? measurement.x : x;\n      y = y === undefined ? measurement.y : y;\n      width = width === undefined ? measurement.width : width;\n      height = height === undefined ? measurement.height : height;\n      group = group === undefined ? self.parentGroup : group;\n      if (width && height) {\n        self.isDrawn = true;\n        for (i = 0, ln = toolbars.length; i < ln; i++) {\n          toolbar = toolbars[i];\n          toolbar.draw(x, y, group);\n        }\n        model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'],\n          (start, end) => {\n            // setTimeout(() => {\n            self.startDt = start[1];\n            self.fromDate.text(self.getDate(start[1]));\n            // self.fromDate.blur(self.getDate(start[1]));\n            // self.fromError.text.attr('text', '');\n            // self.fromError.group.hide();\n            // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n            self.fromDate.removeState('selected');\n            self.fromDate.removeState('errored');\n            self.endDt = end[1];\n            self.toDate.text(self.getDate(end[1]));\n            // self.toDate.blur(self.getDate(end[1]));\n            // self.toError.text.attr('text', '');\n            // self.toError.group.hide();\n            // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n            self.toDate.removeState('selected');\n            self.toDate.removeState('errored');\n            // }, 400);\n          }\n        );\n      }\n\n      if (self.config.orientation === 'vertical') {\n        self.fromError = self.createErrorGroup(self.toDate);\n        self.toError = self.createErrorGroup(self.toDate);\n      } else if (self.config.orientation === 'horizontal') {\n        self.fromError = self.createErrorGroup(self.fromDate);\n        self.toError = self.createErrorGroup(self.toDate);\n      }\n      self.startDataset = self.globalReactiveModel.model['x-axis-absolute-range-start'];\n      self.endDataset = self.globalReactiveModel.model['x-axis-absolute-range-end'];\n      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n      self.minDatestampDiff = self.globalReactiveModel.model['minimum-consecutive-datestamp-diff'];\n      self.minActiveInterval = self.maxXAxisTicks * self.minDatestampDiff;\n      self.containerRight = self.graphics.container.clientLeft + self.graphics.container.clientWidth;\n      self.containerBottom = self.graphics.container.clientTop + self.graphics.container.clientHeight;\n    };\n  }\n  return DateRange;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/fcts-ext-daterange.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}