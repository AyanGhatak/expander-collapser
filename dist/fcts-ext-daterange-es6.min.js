/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(1);
	const StartDateInput = __webpack_require__(2);
	const EndDateInput = __webpack_require__(4);
	const FusionCharts = __webpack_require__(5);
	
	var fc = new FusionCharts();
	
	fc.register('extension', ['date-range-chooser', function (id) {
	  var global = this;
	  var extAPI = global.extAPI;
	  console.log(id);
	
	  // var otherAPI = fc.getExtComponent(id, 'api', 'legacyextapi');
	  // var toolBoxApi = fc.getComponent('api', 'toolbox');
	
	  extAPI({
	    init: function (require) {
	      require('X-Axis', 'Y-Axis', function (x, y) {
	        global.x = x;
	        global.y = y;
	      });
	    },
	    placeInCanvas: function () {
	      // space management
	      var dateRange = new DateRange();
	      dateRange.range = {
	        startDate: 12,
	        endDate: 23
	      };
	      var stDtInp = new StartDateInput();
	      console.log(stDtInp.startDate);
	      var endDtInp = new EndDateInput();
	      console.log(endDtInp.endDate);
	    },
	    draw: function () {
	      // draw extension
	    },
	    dispose: function () {
	      // dispose extension
	    }
	  });
	}]);


/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	class DateRange {
	  /**
	   * Create a DateRange.
	   * @typedef {object} DateRange.range
	   * @property {number} startDate - The start date of the date range.
	   * @property {number} endDate - The end date of the date range.
	   */
	  constructor () {
	    /**
	     * @private
	     */
	    this.dateRange = {
	      startDate: 0,
	      endDate: 0
	    };
	  }
	
	  /**
	   * An object representing the start and end dates.
	   * @type {DateRange.range}
	   */
	  get range () {
	    return this.dateRange;
	  }
	
	  set range (range) {
	    if (range.startDate <= range.endDate) {
	      this.dateRange.startDate = range.startDate;
	      this.dateRange.endDate = range.endDate;
	    }
	  }
	
	  /**
	   * Swaps the start date and the end date of the date range
	   */
	  swapDates () {
	    let temp = this.dateRange.startDate;
	    this.dateRange.startDate = this.dateRange.endDate;
	    this.dateRange.endDate = temp;
	  }
	}
	
	module.exports = DateRange;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateInput = __webpack_require__(3);
	
	/**
	 * A concrete representation of DateInput for the start date.
	 * @extends DateInput
	 * @private
	 */
	class StartDateInput extends DateInput {
	  constructor () {
	    super();
	    /**
	     * @private
	     */
	    this.date = '01/01/1970';
	  }
	
	  /**
	   * The starting date of the TimeSeries chart.
	   * @type string
	   */
	  get startDate () {
	    return this.date;
	  }
	
	  set startDate (dateStr) {
	    this.date = dateStr;
	  }
	}
	
	module.exports = StartDateInput;


/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing a abstract DateInput.
	 * @abstract
	 * @private
	 */
	class DateInput {
	  constructor () {
	    /**
	     * @typedef {object} DateInput.input
	     * @property {number} timestamp - The current time shown on the date input.
	     */
	    /**
	     * @private
	     */
	    this.time = 0;
	  }
	
	  /**
	   * Represents the numeric value of the date
	   * @type number
	   */
	  get timestamp () {
	    return this.time;
	  }
	
	  set timestamp (ms) {
	    this.time = ms;
	  }
	}
	
	module.exports = DateInput;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateInput = __webpack_require__(3);
	
	/**
	 * A concrete representation of DateInput for the end date.
	 * @extends DateInput
	 * @private
	 */
	class EndDateInput extends DateInput {
	  constructor () {
	    super();
	    /**
	     * @private
	     */
	    this.date = '01/01/1970';
	  }
	
	  /**
	   * The ending date of the TimeSeries chart.
	   * @type string
	   */
	  get endDate () {
	    return this.date;
	  }
	
	  set endDate (dateStr) {
	    this.date = dateStr;
	  }
	}
	
	module.exports = EndDateInput;


/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	var FusionCharts = function () {};
	
	FusionCharts.prototype.register = function (ext, arr) {
	  var extName = arr[0];
	  var fn = arr[1];
	  console.log('Currently active extension: ' + extName);
	  fn.bind(this, 565)();
	};
	
	FusionCharts.prototype.getComponent = function (componentType, componentName) {
	  var toolBox = {
	    x: 24,
	    y: 56,
	    width: 100,
	    height: 20,
	    index: 4
	  };
	
	  if (componentType === 'api' && componentName === 'toolbox') {
	    return toolBox;
	  }
	
	  return null;
	};
	
	FusionCharts.prototype.extAPI = function (obj) {
	  obj.init(function () {
	    var argsToApply = [];
	    var cb = arguments[arguments.length - 1];
	
	    for (var i = 0; i < arguments.length - 1; i++) {
	      if (arguments[i] === 'X-Axis') {
	        argsToApply.push(156772);
	      } else if (arguments[i] === 'Y-Axis') {
	        argsToApply.push(156765);
	      }
	    }
	    cb.apply(this, argsToApply);
	  });
	
	  obj.placeInCanvas();
	
	  obj.draw();
	
	  obj.dispose();
	};
	
	module.exports = FusionCharts;


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGE1NTE2ZTI0OWM2Njk1YjVkZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZjdHMtZXh0LXN0YXJ0ZGF0ZWlucHV0LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZjdHMtZXh0LWVuZGRhdGVpbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZnVzaW9uY2hhcnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7Ozs7Ozs7QUMxQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6ImZjdHMtZXh0LWRhdGVyYW5nZS1lczYubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAwYTU1MTZlMjQ5YzY2OTViNWRlZlxuICoqLyIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IERhdGVSYW5nZSA9IHJlcXVpcmUoJy4vZmN0cy1leHQtZGF0ZXJhbmdlJyk7XG5jb25zdCBTdGFydERhdGVJbnB1dCA9IHJlcXVpcmUoJy4vZmN0cy1leHQtc3RhcnRkYXRlaW5wdXQnKTtcbmNvbnN0IEVuZERhdGVJbnB1dCA9IHJlcXVpcmUoJy4vZmN0cy1leHQtZW5kZGF0ZWlucHV0Jyk7XG5jb25zdCBGdXNpb25DaGFydHMgPSByZXF1aXJlKCcuLi9saWIvZnVzaW9uY2hhcnRzJyk7XG5cbnZhciBmYyA9IG5ldyBGdXNpb25DaGFydHMoKTtcblxuZmMucmVnaXN0ZXIoJ2V4dGVuc2lvbicsIFsnZGF0ZS1yYW5nZS1jaG9vc2VyJywgZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBnbG9iYWwgPSB0aGlzO1xuICB2YXIgZXh0QVBJID0gZ2xvYmFsLmV4dEFQSTtcbiAgY29uc29sZS5sb2coaWQpO1xuXG4gIC8vIHZhciBvdGhlckFQSSA9IGZjLmdldEV4dENvbXBvbmVudChpZCwgJ2FwaScsICdsZWdhY3lleHRhcGknKTtcbiAgLy8gdmFyIHRvb2xCb3hBcGkgPSBmYy5nZXRDb21wb25lbnQoJ2FwaScsICd0b29sYm94Jyk7XG5cbiAgZXh0QVBJKHtcbiAgICBpbml0OiBmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgICAgcmVxdWlyZSgnWC1BeGlzJywgJ1ktQXhpcycsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGdsb2JhbC54ID0geDtcbiAgICAgICAgZ2xvYmFsLnkgPSB5O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwbGFjZUluQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzcGFjZSBtYW5hZ2VtZW50XG4gICAgICB2YXIgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZSgpO1xuICAgICAgZGF0ZVJhbmdlLnJhbmdlID0ge1xuICAgICAgICBzdGFydERhdGU6IDEyLFxuICAgICAgICBlbmREYXRlOiAyM1xuICAgICAgfTtcbiAgICAgIHZhciBzdER0SW5wID0gbmV3IFN0YXJ0RGF0ZUlucHV0KCk7XG4gICAgICBjb25zb2xlLmxvZyhzdER0SW5wLnN0YXJ0RGF0ZSk7XG4gICAgICB2YXIgZW5kRHRJbnAgPSBuZXcgRW5kRGF0ZUlucHV0KCk7XG4gICAgICBjb25zb2xlLmxvZyhlbmREdElucC5lbmREYXRlKTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGRyYXcgZXh0ZW5zaW9uXG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkaXNwb3NlIGV4dGVuc2lvblxuICAgIH1cbiAgfSk7XG59XSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIERhdGVSYW5nZS5cbiAqL1xuY2xhc3MgRGF0ZVJhbmdlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVSYW5nZS5cbiAgICogQHR5cGVkZWYge29iamVjdH0gRGF0ZVJhbmdlLnJhbmdlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydERhdGUgLSBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZGF0ZSByYW5nZS5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZERhdGUgLSBUaGUgZW5kIGRhdGUgb2YgdGhlIGRhdGUgcmFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRhdGVSYW5nZSA9IHtcbiAgICAgIHN0YXJ0RGF0ZTogMCxcbiAgICAgIGVuZERhdGU6IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMuXG4gICAqIEB0eXBlIHtEYXRlUmFuZ2UucmFuZ2V9XG4gICAqL1xuICBnZXQgcmFuZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZTtcbiAgfVxuXG4gIHNldCByYW5nZSAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnREYXRlIDw9IHJhbmdlLmVuZERhdGUpIHtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZSA9IHJhbmdlLnN0YXJ0RGF0ZTtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlLmVuZERhdGUgPSByYW5nZS5lbmREYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwcyB0aGUgc3RhcnQgZGF0ZSBhbmQgdGhlIGVuZCBkYXRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gICAqL1xuICBzd2FwRGF0ZXMgKCkge1xuICAgIGxldCB0ZW1wID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlO1xuICAgIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZSA9IHRoaXMuZGF0ZVJhbmdlLmVuZERhdGU7XG4gICAgdGhpcy5kYXRlUmFuZ2UuZW5kRGF0ZSA9IHRlbXA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlUmFuZ2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2ZjdHMtZXh0LWRhdGVyYW5nZS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IERhdGVJbnB1dCA9IHJlcXVpcmUoJy4vZmN0cy1leHQtZGF0ZWlucHV0Jyk7XG5cbi8qKlxuICogQSBjb25jcmV0ZSByZXByZXNlbnRhdGlvbiBvZiBEYXRlSW5wdXQgZm9yIHRoZSBzdGFydCBkYXRlLlxuICogQGV4dGVuZHMgRGF0ZUlucHV0XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGFydERhdGVJbnB1dCBleHRlbmRzIERhdGVJbnB1dCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kYXRlID0gJzAxLzAxLzE5NzAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFydGluZyBkYXRlIG9mIHRoZSBUaW1lU2VyaWVzIGNoYXJ0LlxuICAgKiBAdHlwZSBzdHJpbmdcbiAgICovXG4gIGdldCBzdGFydERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGU7XG4gIH1cblxuICBzZXQgc3RhcnREYXRlIChkYXRlU3RyKSB7XG4gICAgdGhpcy5kYXRlID0gZGF0ZVN0cjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXJ0RGF0ZUlucHV0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9mY3RzLWV4dC1zdGFydGRhdGVpbnB1dC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgYWJzdHJhY3QgRGF0ZUlucHV0LlxuICogQGFic3RyYWN0XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRlSW5wdXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gRGF0ZUlucHV0LmlucHV0XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBjdXJyZW50IHRpbWUgc2hvd24gb24gdGhlIGRhdGUgaW5wdXQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIGRhdGVcbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBnZXQgdGltZXN0YW1wICgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lO1xuICB9XG5cbiAgc2V0IHRpbWVzdGFtcCAobXMpIHtcbiAgICB0aGlzLnRpbWUgPSBtcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGVJbnB1dDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvZmN0cy1leHQtZGF0ZWlucHV0LmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgRGF0ZUlucHV0ID0gcmVxdWlyZSgnLi9mY3RzLWV4dC1kYXRlaW5wdXQnKTtcblxuLyoqXG4gKiBBIGNvbmNyZXRlIHJlcHJlc2VudGF0aW9uIG9mIERhdGVJbnB1dCBmb3IgdGhlIGVuZCBkYXRlLlxuICogQGV4dGVuZHMgRGF0ZUlucHV0XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFbmREYXRlSW5wdXQgZXh0ZW5kcyBEYXRlSW5wdXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGF0ZSA9ICcwMS8wMS8xOTcwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZW5kaW5nIGRhdGUgb2YgdGhlIFRpbWVTZXJpZXMgY2hhcnQuXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKi9cbiAgZ2V0IGVuZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGU7XG4gIH1cblxuICBzZXQgZW5kRGF0ZSAoZGF0ZVN0cikge1xuICAgIHRoaXMuZGF0ZSA9IGRhdGVTdHI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmREYXRlSW5wdXQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2ZjdHMtZXh0LWVuZGRhdGVpbnB1dC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBGdXNpb25DaGFydHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuRnVzaW9uQ2hhcnRzLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChleHQsIGFycikge1xuICB2YXIgZXh0TmFtZSA9IGFyclswXTtcbiAgdmFyIGZuID0gYXJyWzFdO1xuICBjb25zb2xlLmxvZygnQ3VycmVudGx5IGFjdGl2ZSBleHRlbnNpb246ICcgKyBleHROYW1lKTtcbiAgZm4uYmluZCh0aGlzLCA1NjUpKCk7XG59O1xuXG5GdXNpb25DaGFydHMucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBjb21wb25lbnROYW1lKSB7XG4gIHZhciB0b29sQm94ID0ge1xuICAgIHg6IDI0LFxuICAgIHk6IDU2LFxuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAyMCxcbiAgICBpbmRleDogNFxuICB9O1xuXG4gIGlmIChjb21wb25lbnRUeXBlID09PSAnYXBpJyAmJiBjb21wb25lbnROYW1lID09PSAndG9vbGJveCcpIHtcbiAgICByZXR1cm4gdG9vbEJveDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuRnVzaW9uQ2hhcnRzLnByb3RvdHlwZS5leHRBUEkgPSBmdW5jdGlvbiAob2JqKSB7XG4gIG9iai5pbml0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJnc1RvQXBwbHkgPSBbXTtcbiAgICB2YXIgY2IgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzW2ldID09PSAnWC1BeGlzJykge1xuICAgICAgICBhcmdzVG9BcHBseS5wdXNoKDE1Njc3Mik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1tpXSA9PT0gJ1ktQXhpcycpIHtcbiAgICAgICAgYXJnc1RvQXBwbHkucHVzaCgxNTY3NjUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYi5hcHBseSh0aGlzLCBhcmdzVG9BcHBseSk7XG4gIH0pO1xuXG4gIG9iai5wbGFjZUluQ2FudmFzKCk7XG5cbiAgb2JqLmRyYXcoKTtcblxuICBvYmouZGlzcG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdXNpb25DaGFydHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Z1c2lvbmNoYXJ0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=