/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(2);
	
	// ;(function (factory) {
	//   factory(FusionCharts);
	// })(function (FC) {
	//   FC.register('extension', ['date-range-chooser', function (id) {
	    // var global = this;
	    // var extAPI = global.extAPI;
	
	    // var otherAPI = FC.getExtComponent(id, 'api', 'legacyextapi');
	    // var toolBoxApi = FC.getComponent('api', 'toolbox');
	
	window.dr = new DateRange();
	    // extAPI(window.dr);
	//   }]);
	// });


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	class DateRange {
	  constructor () {
	    /**
	     * @private
	     */
	    this.startDt = 0;
	    this.endDt = 0;
	    this.startText = {
	      attr: function () {}
	    };
	    this.endText = {
	      attr: function () {}
	    };
	  }
	
	  /**
	   * An object representing the start and end dates.
	   * @type {DateRange.range}
	   */
	  get startDate () {
	    return this.startDt;
	  }
	
	  set startDate (startDt) {
	    let startTimestamp = +new Date(startDt);
	    if (startTimestamp <= this.endDt) {
	      this.startDt = startTimestamp;
	      console.log(this.startDt);
	    }
	  }
	
	  get endDate () {
	    return this.endDt;
	  }
	
	  set endDate (endDt) {
	    let endTimestamp = +new Date(endDt);
	    if (endTimestamp >= this.startDt) {
	      this.endDt = endTimestamp;
	      console.log(this.endDt);
	    }
	  }
	
	  init (require) {
	    var self = this;
	    require('X-Axis', 'graphics', 'chart', function (x, graphics, chart) {
	      self.x = x;
	      self.paper = graphics;
	      self.chart = chart;
	    });
	  }
	
	  placeInCanvas () {
	    this.range = {
	      startDate: 12,
	      endDate: 23
	    };
	  }
	
	  draw () {
	    var paper = this.paper;
	
	    var startLabel = paper.text(20, 22, 'From: ');
	    startLabel.attr('font-family', 'sans-serif');
	    startLabel.attr('fill', '#000');
	    var startRect = paper.rect(50, 10, 90, 25);
	    startRect.attr('stroke', '#000');
	    this.startText = paper.text(95, 22, this.getFormattedDate(this.startDate));
	    this.startText.attr('font-family', 'sans-serif');
	    this.startText.attr('fill', '#000');
	
	    var endLabel = paper.text(170, 22, 'To: ');
	    endLabel.attr('font-family', 'sans-serif');
	    endLabel.attr('fill', '#000');
	    var endRect = paper.rect(190, 10, 90, 25);
	    endRect.attr('stroke', '#000');
	    this.endText = paper.text(235, 22, this.getFormattedDate(this.endDate));
	    this.endText.attr('font-family', 'sans-serif');
	    this.endText.attr('fill', '#000');
	  }
	
	  dispose () {
	    // TODO: dispose extension
	  }
	
	  /**
	   * Swaps the start date and the end date of the date range
	   * @private
	   */
	  swapDates () {
	    let temp = this.dateRange.startDate;
	    this.dateRange.startDate = this.dateRange.endDate;
	    this.dateRange.endDate = temp;
	  }
	
	  /**
	   * Syncs the daterange shown by the FusionCharts time series chart and the Date Range Chooser
	   * @private
	   */
	  syncRange () {}
	
	  /**
	   * Returns a formatted date string from FusionCharts when given a UNIX timestamp
	   * @param  {number} timestamp - A UNIX timestamp to be converted to a date string
	   * @return {string} - A date string which is equivalent to the given timestamp
	   */
	  getFormattedDate (timestamp) {
	    return this.chart.getFormattedDate(timestamp);
	  }
	
	  /**
	   * Returns a UNIX timestamp from FusionCharts when given a formatted date string
	   * @param  {string} dateString - A date string to be converted to a UNIX timestamp
	   * @return {number} A UNIX timestamp which is equivalent to the given date string
	   */
	  getTimestamp (dateString) {
	    return this.chart.getTimestamp(dateString);
	  }
	
	  /**
	   * Sets the configurable options of the extension (e.g. cosmetics)
	   * @param {Object} configObj The configuration object containing various extension options
	   */
	  setConfig (configObj) {}
	
	  /**
	   * Gets the configurable options of the extension (e.g. cosmetics)
	   * @return {object} configObj The configuration object containing various extension options
	   */
	  getConfig () {
	    return {
	      calendarVisible: 'false'
	    };
	  }
	}
	
	module.exports = DateRange;


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWU1OGZmNTJkZTMyZjhlZTRkMDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUEsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sS0FBSTs7Ozs7OztBQ2hCSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJmY3RzLWV4dC1kYXRlcmFuZ2UtZXM2Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFlNThmZjUyZGUzMmY4ZWU0ZDAxIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgRGF0ZVJhbmdlID0gcmVxdWlyZSgnLi9mY3RzLWV4dC1kYXRlcmFuZ2UnKTtcblxuLy8gOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuLy8gICBmYWN0b3J5KEZ1c2lvbkNoYXJ0cyk7XG4vLyB9KShmdW5jdGlvbiAoRkMpIHtcbi8vICAgRkMucmVnaXN0ZXIoJ2V4dGVuc2lvbicsIFsnZGF0ZS1yYW5nZS1jaG9vc2VyJywgZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gdmFyIGdsb2JhbCA9IHRoaXM7XG4gICAgLy8gdmFyIGV4dEFQSSA9IGdsb2JhbC5leHRBUEk7XG5cbiAgICAvLyB2YXIgb3RoZXJBUEkgPSBGQy5nZXRFeHRDb21wb25lbnQoaWQsICdhcGknLCAnbGVnYWN5ZXh0YXBpJyk7XG4gICAgLy8gdmFyIHRvb2xCb3hBcGkgPSBGQy5nZXRDb21wb25lbnQoJ2FwaScsICd0b29sYm94Jyk7XG5cbndpbmRvdy5kciA9IG5ldyBEYXRlUmFuZ2UoKTtcbiAgICAvLyBleHRBUEkod2luZG93LmRyKTtcbi8vICAgfV0pO1xuLy8gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgRGF0ZVJhbmdlLlxuICovXG5jbGFzcyBEYXRlUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0RHQgPSAwO1xuICAgIHRoaXMuZW5kRHQgPSAwO1xuICAgIHRoaXMuc3RhcnRUZXh0ID0ge1xuICAgICAgYXR0cjogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIHRoaXMuZW5kVGV4dCA9IHtcbiAgICAgIGF0dHI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzLlxuICAgKiBAdHlwZSB7RGF0ZVJhbmdlLnJhbmdlfVxuICAgKi9cbiAgZ2V0IHN0YXJ0RGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnREdDtcbiAgfVxuXG4gIHNldCBzdGFydERhdGUgKHN0YXJ0RHQpIHtcbiAgICBsZXQgc3RhcnRUaW1lc3RhbXAgPSArbmV3IERhdGUoc3RhcnREdCk7XG4gICAgaWYgKHN0YXJ0VGltZXN0YW1wIDw9IHRoaXMuZW5kRHQpIHtcbiAgICAgIHRoaXMuc3RhcnREdCA9IHN0YXJ0VGltZXN0YW1wO1xuICAgICAgY29uc29sZS5sb2codGhpcy5zdGFydER0KTtcbiAgICB9XG4gIH1cblxuICBnZXQgZW5kRGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kRHQ7XG4gIH1cblxuICBzZXQgZW5kRGF0ZSAoZW5kRHQpIHtcbiAgICBsZXQgZW5kVGltZXN0YW1wID0gK25ldyBEYXRlKGVuZER0KTtcbiAgICBpZiAoZW5kVGltZXN0YW1wID49IHRoaXMuc3RhcnREdCkge1xuICAgICAgdGhpcy5lbmREdCA9IGVuZFRpbWVzdGFtcDtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuZW5kRHQpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQgKHJlcXVpcmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVxdWlyZSgnWC1BeGlzJywgJ2dyYXBoaWNzJywgJ2NoYXJ0JywgZnVuY3Rpb24gKHgsIGdyYXBoaWNzLCBjaGFydCkge1xuICAgICAgc2VsZi54ID0geDtcbiAgICAgIHNlbGYucGFwZXIgPSBncmFwaGljcztcbiAgICAgIHNlbGYuY2hhcnQgPSBjaGFydDtcbiAgICB9KTtcbiAgfVxuXG4gIHBsYWNlSW5DYW52YXMgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB7XG4gICAgICBzdGFydERhdGU6IDEyLFxuICAgICAgZW5kRGF0ZTogMjNcbiAgICB9O1xuICB9XG5cbiAgZHJhdyAoKSB7XG4gICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcblxuICAgIHZhciBzdGFydExhYmVsID0gcGFwZXIudGV4dCgyMCwgMjIsICdGcm9tOiAnKTtcbiAgICBzdGFydExhYmVsLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKTtcbiAgICBzdGFydExhYmVsLmF0dHIoJ2ZpbGwnLCAnIzAwMCcpO1xuICAgIHZhciBzdGFydFJlY3QgPSBwYXBlci5yZWN0KDUwLCAxMCwgOTAsIDI1KTtcbiAgICBzdGFydFJlY3QuYXR0cignc3Ryb2tlJywgJyMwMDAnKTtcbiAgICB0aGlzLnN0YXJ0VGV4dCA9IHBhcGVyLnRleHQoOTUsIDIyLCB0aGlzLmdldEZvcm1hdHRlZERhdGUodGhpcy5zdGFydERhdGUpKTtcbiAgICB0aGlzLnN0YXJ0VGV4dC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJyk7XG4gICAgdGhpcy5zdGFydFRleHQuYXR0cignZmlsbCcsICcjMDAwJyk7XG5cbiAgICB2YXIgZW5kTGFiZWwgPSBwYXBlci50ZXh0KDE3MCwgMjIsICdUbzogJyk7XG4gICAgZW5kTGFiZWwuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpO1xuICAgIGVuZExhYmVsLmF0dHIoJ2ZpbGwnLCAnIzAwMCcpO1xuICAgIHZhciBlbmRSZWN0ID0gcGFwZXIucmVjdCgxOTAsIDEwLCA5MCwgMjUpO1xuICAgIGVuZFJlY3QuYXR0cignc3Ryb2tlJywgJyMwMDAnKTtcbiAgICB0aGlzLmVuZFRleHQgPSBwYXBlci50ZXh0KDIzNSwgMjIsIHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSh0aGlzLmVuZERhdGUpKTtcbiAgICB0aGlzLmVuZFRleHQuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpO1xuICAgIHRoaXMuZW5kVGV4dC5hdHRyKCdmaWxsJywgJyMwMDAnKTtcbiAgfVxuXG4gIGRpc3Bvc2UgKCkge1xuICAgIC8vIFRPRE86IGRpc3Bvc2UgZXh0ZW5zaW9uXG4gIH1cblxuICAvKipcbiAgICogU3dhcHMgdGhlIHN0YXJ0IGRhdGUgYW5kIHRoZSBlbmQgZGF0ZSBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3dhcERhdGVzICgpIHtcbiAgICBsZXQgdGVtcCA9IHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZTtcbiAgICB0aGlzLmRhdGVSYW5nZS5zdGFydERhdGUgPSB0aGlzLmRhdGVSYW5nZS5lbmREYXRlO1xuICAgIHRoaXMuZGF0ZVJhbmdlLmVuZERhdGUgPSB0ZW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNzIHRoZSBkYXRlcmFuZ2Ugc2hvd24gYnkgdGhlIEZ1c2lvbkNoYXJ0cyB0aW1lIHNlcmllcyBjaGFydCBhbmQgdGhlIERhdGUgUmFuZ2UgQ2hvb3NlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3luY1JhbmdlICgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgZnJvbSBGdXNpb25DaGFydHMgd2hlbiBnaXZlbiBhIFVOSVggdGltZXN0YW1wXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZXN0YW1wIC0gQSBVTklYIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBkYXRlIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSBkYXRlIHN0cmluZyB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB0aW1lc3RhbXBcbiAgICovXG4gIGdldEZvcm1hdHRlZERhdGUgKHRpbWVzdGFtcCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldEZvcm1hdHRlZERhdGUodGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVU5JWCB0aW1lc3RhbXAgZnJvbSBGdXNpb25DaGFydHMgd2hlbiBnaXZlbiBhIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGRhdGVTdHJpbmcgLSBBIGRhdGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byBhIFVOSVggdGltZXN0YW1wXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBVTklYIHRpbWVzdGFtcCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBkYXRlIHN0cmluZ1xuICAgKi9cbiAgZ2V0VGltZXN0YW1wIChkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0VGltZXN0YW1wKGRhdGVTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIG9mIHRoZSBleHRlbnNpb24gKGUuZy4gY29zbWV0aWNzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIHZhcmlvdXMgZXh0ZW5zaW9uIG9wdGlvbnNcbiAgICovXG4gIHNldENvbmZpZyAoY29uZmlnT2JqKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmFibGUgb3B0aW9ucyBvZiB0aGUgZXh0ZW5zaW9uIChlLmcuIGNvc21ldGljcylcbiAgICogQHJldHVybiB7b2JqZWN0fSBjb25maWdPYmogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdmFyaW91cyBleHRlbnNpb24gb3B0aW9uc1xuICAgKi9cbiAgZ2V0Q29uZmlnICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsZW5kYXJWaXNpYmxlOiAnZmFsc2UnXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGVSYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ZjdHMtZXh0LWRhdGVyYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9