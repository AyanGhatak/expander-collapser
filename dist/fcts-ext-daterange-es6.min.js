/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(2);
	
	window.dr = new DateRange();
	
	;(function (env, factory) {
	  if (typeof module === 'object' && module.exports) {
	    module.exports = env.document
	       ? factory(env) : function (win) {
	         if (!win.document) {
	           throw new Error('Window with document not present');
	         }
	         return factory(win, true);
	       };
	  } else {
	    env.DateRangeChooser = factory(env, true);
	  }
	})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {
	  var FC = _window.FusionCharts;
	  FC.register('extension', ['private', 'DateRangeChooser', function () {
	    FC.registerComponent('extensions', 'DateRangeChooser', DateRange);
	  }]);
	});


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	class DateRange {
	  constructor () {
	    /**
	     * @private
	     */
	    this.startDt = 0;
	    this.endDt = 0;
	    this.startDataset = 0;
	    this.endDataset = 0;
	    this.toolbox = FusionCharts.getComponent('api', 'toolbox');
	    this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	    this.ComponentGroup = this.toolbox.ComponentGroup;
	    this.SymbolStore = this.toolbox.SymbolStore;
	    this.startText = {
	      attr: function () {}
	    };
	    this.endText = {
	      attr: function () {}
	    };
	  }
	
	  /**
	   * An object representing the start and end dates.
	   * @type {DateRange.range}
	   */
	  get startDate () {
	    return this.startDt;
	  }
	
	  set startDate (startDt) {
	    let startTimestamp = +new Date(startDt);
	    if (startTimestamp <= this.endDt) {
	      this.startDt = startTimestamp;
	      this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;
	    }
	  }
	
	  get endDate () {
	    return this.endDt;
	  }
	
	  set endDate (endDt) {
	    let endTimestamp = +new Date(endDt);
	    if (endTimestamp >= this.startDt) {
	      this.endDt = endTimestamp;
	      this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;
	    }
	  }
	
	  /**
	   * Swaps the start date and the end date of the date range
	   * @private
	   */
	  swapDates () {
	    let temp = this.dateRange.startDate;
	    this.dateRange.startDate = this.dateRange.endDate;
	    this.dateRange.endDate = temp;
	  }
	
	  /**
	   * Syncs the daterange shown by the FusionCharts time series chart and the Date Range Chooser
	   * @private
	   */
	  syncRange () {}
	
	  /**
	   * Returns a formatted date string from FusionCharts when given a UNIX timestamp
	   * @param  {number} timestamp - A UNIX timestamp to be converted to a date string
	   * @return {string} - A date string which is equivalent to the given timestamp
	   */
	  getFormattedDate (timestamp) {
	    return this.chart.getFormattedDate(timestamp);
	  }
	
	  /**
	   * Returns a UNIX timestamp from FusionCharts when given a formatted date string
	   * @param  {string} dateString - A date string to be converted to a UNIX timestamp
	   * @return {number} A UNIX timestamp which is equivalent to the given date string
	   */
	  getTimestamp (dateString) {
	    return this.chart.getTimestamp(dateString);
	  }
	
	  /**
	   * Sets the configurable options of the extension (e.g. cosmetics)
	   * @param {Object} configObj The configuration object containing various extension options
	   */
	  setConfig (configObj) {}
	
	  /**
	   * Gets the configurable options of the extension (e.g. cosmetics)
	   * @return {object} configObj The configuration object containing various extension options
	   */
	  getConfig () {
	    return {
	      calendarVisible: 'false'
	    };
	  }
	
	  /**
	   * Fusioncharts life cycle method for extension
	   */
	  init (require) {
	    var instance = this;
	    require([
	      'xAxis',
	      'yAxis',
	      'graphics',
	      'chart',
	      'dataset',
	      'PlotManager',
	      'canvasConfig',
	      'MarkerManager',
	      'reactiveModel',
	      'globalReactiveModel',
	      'spaceManagerInstance',
	      'smartLabel',
	      'chartInstance',
	      function (
	            xAxis,
	            yAxis,
	            graphics,
	            chart,
	            dataset,
	            plotManager,
	            canvasConfig,
	            markerManager,
	            reactiveModel,
	            globalReactiveModel,
	            spaceManagerInstance,
	            smartLabel) {
	        instance.xAxis = xAxis;
	        instance.yAxis = yAxis;
	        instance.graphics = graphics;
	        instance.chart = chart;
	        instance.dataset = dataset;
	        instance.plotManager = plotManager;
	        instance.markerManager = markerManager;
	        instance.canvasConfig = canvasConfig;
	        instance.reactiveModel = reactiveModel;
	        instance.globalReactiveModel = globalReactiveModel;
	        instance.spaceManagerInstance = spaceManagerInstance;
	        instance.smartLabel = smartLabel;
	      }
	    ]);
	    this.spaceManagerInstance = instance.spaceManagerInstance;
	    this.globalReactiveModel = instance.globalReactiveModel;
	    this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	    this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	    this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	    this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	    this.toolbars = [];
	    this.measurement = {};
	    this.toolbars.push(this.createToolbar());
	    // console.log(this.createToolbar());
	    // console.log(this.dateStart, this.dateEnd);
	    return this;
	  };
	
	  createToolbar () {
	    var toolbar,
	      self = this,
	      fromDateLabel,
	      toDateLabel,
	      group,
	      fromFormattedDate,
	      toFormattedDate;
	
	    self.fromDate = {};
	    self.toDate = {};
	
	    fromFormattedDate = new Date(this.startDt).toLocaleDateString();
	
	    toFormattedDate = new Date(this.endDt).toLocaleDateString();
	
	    toolbar = new this.HorizontalToolbar({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    toolbar.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    group = new this.toolbox.ComponentGroup({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    group.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    fromDateLabel = new this.toolbox.Label('From:', {
	      smartLabel: this.smartLabel,
	      paper: this.graphics.paper
	    }, {
	      text: {
	        style: {
	          'font-size': '15',
	          'fontFamily': 'MyriadPro'
	        }
	      }
	    });
	
	    self.fromDate = new this.toolbox.InputTextBoxSymbol({
	      width: 120,
	      height: 25
	    }, {
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    }, {
	      strokeWidth: 1,
	      stroke: 'rgba(102,102,102,0.5)',
	      symbolStrokeWidth: 0,
	      btnTextStyle: {
	        fontSize: 14
	      },
	      label: fromFormattedDate
	    });
	
	    toDateLabel = new this.toolbox.Label('To:', {
	      smartLabel: this.smartLabel,
	      paper: this.graphics.paper
	    }, {
	      text: {
	        style: {
	          'font-size': '15',
	          'fontFamily': 'MyriadPro'
	        }
	      }
	    });
	
	    self.toDate = new this.toolbox.InputTextBoxSymbol({
	      width: 120,
	      height: 25
	    }, {
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    }, {
	      strokeWidth: 1,
	      stroke: 'rgba(102,102,102,0.5)',
	      symbolStrokeWidth: 0,
	      btnTextStyle: {
	        fontSize: 14
	      },
	      label: toFormattedDate
	    });
	
	    self.fromDate.attachEventHandlers({
	      click: {
	        fn: self.fromDate.edit
	      },
	      textOnBlur: function () {
	        self.fromDate.blur();
	        self.startDate = self.fromDate.getText();
	        console.log(self.fromDate.getText());
	      }
	    });
	
	    self.toDate.attachEventHandlers({
	      click: {
	        fn: self.toDate.edit
	      },
	      textOnBlur: function () {
	        self.toDate.blur();
	        console.log(self.toDate.getText());
	        self.endDate = self.toDate.getText();
	      }
	    });
	
	    this.SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
	      var x1 = x - w / 2 + padX / 2,
	        x2 = x + w / 2 - padX / 2,
	        y1 = y - h / 2 + padY / 2,
	        y2 = y + h / 2 - padY / 2;
	
	      return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
	    });
	
	    group.addSymbol(fromDateLabel);
	    group.addSymbol(self.fromDate);
	    group.addSymbol(toDateLabel);
	    group.addSymbol(self.toDate);
	    toolbar.addComponent(group);
	    return toolbar;
	  };
	
	  getLogicalSpace (availableWidth, availableHeight) {
	    availableWidth /= 2;
	    var logicalSpace,
	      width = 0,
	      height = 0,
	      i,
	      ln;
	
	    for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	      logicalSpace = this.toolbars[i].getLogicalSpace();
	      width = Math.max(logicalSpace.width, width);
	      height += logicalSpace.height;
	      this.toolbars[i].width = logicalSpace.width;
	      this.toolbars[i].height = logicalSpace.height;
	    }
	    height += this.padding;
	    return {
	      width: width > availableWidth ? 0 : width,
	      height: height > availableHeight ? 0 : height
	    };
	  };
	
	  placeInCanvas () {
	    var self = this;
	    self.padding = 5;
	    self.spaceManagerInstance.add([{
	      name: function () {
	        return 'ToolBoxExt';
	      },
	      ref: function (obj) {
	        return obj['0'];
	      },
	      self: function () {
	        return self;
	      },
	      priority: function () {
	        return 2;
	      },
	      layout: function (obj) {
	        return obj.inline;
	      },
	      orientation: [{
	        type: function (obj) {
	          return obj.horizontal;
	        },
	        position: [{
	          type: function (obj) {
	            return obj.top;
	          },
	          alignment: [{
	            type: function (obj) {
	              return obj.left;
	            },
	            dimensions: [function () {
	              var parent = this.getParentComponentGroup();
	              return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	            }]
	          }]
	        }]
	      }]
	    }]);
	  };
	
	  setDrawingConfiguration (x, y, width, height, group) {
	    var mes = this.measurement;
	    mes.x = x;
	    mes.y = y;
	    mes.width = width;
	    mes.height = height;
	
	    this.parentGroup = group;
	
	    return this;
	  };
	
	  draw (x, y, width, height, group) {
	    var measurement = this.measurement,
	      toolbars = this.toolbars,
	      ln,
	      i,
	      toolbar,
	      model = this.globalReactiveModel,
	      self = this;
	    console.log(model);
	    x = x === undefined ? measurement.x : x;
	    y = y === undefined ? measurement.y : y;
	    width = width === undefined ? measurement.width : width;
	    height = height === undefined ? measurement.height : height;
	    group = group === undefined ? this.parentGroup : group;
	    if (width && height) {
	      for (i = 0, ln = toolbars.length; i < ln; i++) {
	        toolbar = toolbars[i];
	        toolbar.draw(x, y);
	      }
	    }
	
	    model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'], function (start, end) {
	      self.fromDate.blur(new Date(start[1]).toLocaleDateString());
	      self.toDate.blur(new Date(end[1]).toLocaleDateString());
	    });
	  };
	}
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = DateRange;
	} else {
	  window.StandardPeriod = DateRange;
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTA1N2VmYmM1MDJlMDUzZWJkZjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1gsVUFBUztBQUNULFFBQU87QUFDUCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBIiwiZmlsZSI6ImZjdHMtZXh0LWRhdGVyYW5nZS1lczYubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOTA1N2VmYmM1MDJlMDUzZWJkZjYiLCIndXNlIHN0cmljdCc7XG5jb25zdCBEYXRlUmFuZ2UgPSByZXF1aXJlKCcuL2ZjdHMtZXh0LWRhdGVyYW5nZScpO1xuXG53aW5kb3cuZHIgPSBuZXcgRGF0ZVJhbmdlKCk7XG5cbjsoZnVuY3Rpb24gKGVudiwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudi5kb2N1bWVudFxuICAgICAgID8gZmFjdG9yeShlbnYpIDogZnVuY3Rpb24gKHdpbikge1xuICAgICAgICAgaWYgKCF3aW4uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgd2l0aCBkb2N1bWVudCBub3QgcHJlc2VudCcpO1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZhY3Rvcnkod2luLCB0cnVlKTtcbiAgICAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVudi5EYXRlUmFuZ2VDaG9vc2VyID0gZmFjdG9yeShlbnYsIHRydWUpO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uIChfd2luZG93LCB3aW5kb3dFeGlzdHMpIHtcbiAgdmFyIEZDID0gX3dpbmRvdy5GdXNpb25DaGFydHM7XG4gIEZDLnJlZ2lzdGVyKCdleHRlbnNpb24nLCBbJ3ByaXZhdGUnLCAnRGF0ZVJhbmdlQ2hvb3NlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBGQy5yZWdpc3RlckNvbXBvbmVudCgnZXh0ZW5zaW9ucycsICdEYXRlUmFuZ2VDaG9vc2VyJywgRGF0ZVJhbmdlKTtcbiAgfV0pO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgRGF0ZVJhbmdlLlxuICovXG5jbGFzcyBEYXRlUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0RHQgPSAwO1xuICAgIHRoaXMuZW5kRHQgPSAwO1xuICAgIHRoaXMuc3RhcnREYXRhc2V0ID0gMDtcbiAgICB0aGlzLmVuZERhdGFzZXQgPSAwO1xuICAgIHRoaXMudG9vbGJveCA9IEZ1c2lvbkNoYXJ0cy5nZXRDb21wb25lbnQoJ2FwaScsICd0b29sYm94Jyk7XG4gICAgdGhpcy5Ib3Jpem9udGFsVG9vbGJhciA9IHRoaXMudG9vbGJveC5Ib3Jpem9udGFsVG9vbGJhcjtcbiAgICB0aGlzLkNvbXBvbmVudEdyb3VwID0gdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwO1xuICAgIHRoaXMuU3ltYm9sU3RvcmUgPSB0aGlzLnRvb2xib3guU3ltYm9sU3RvcmU7XG4gICAgdGhpcy5zdGFydFRleHQgPSB7XG4gICAgICBhdHRyOiBmdW5jdGlvbiAoKSB7fVxuICAgIH07XG4gICAgdGhpcy5lbmRUZXh0ID0ge1xuICAgICAgYXR0cjogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMuXG4gICAqIEB0eXBlIHtEYXRlUmFuZ2UucmFuZ2V9XG4gICAqL1xuICBnZXQgc3RhcnREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydER0O1xuICB9XG5cbiAgc2V0IHN0YXJ0RGF0ZSAoc3RhcnREdCkge1xuICAgIGxldCBzdGFydFRpbWVzdGFtcCA9ICtuZXcgRGF0ZShzdGFydER0KTtcbiAgICBpZiAoc3RhcnRUaW1lc3RhbXAgPD0gdGhpcy5lbmREdCkge1xuICAgICAgdGhpcy5zdGFydER0ID0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLXN0YXJ0J10gPSB0aGlzLnN0YXJ0RHQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGVuZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZER0O1xuICB9XG5cbiAgc2V0IGVuZERhdGUgKGVuZER0KSB7XG4gICAgbGV0IGVuZFRpbWVzdGFtcCA9ICtuZXcgRGF0ZShlbmREdCk7XG4gICAgaWYgKGVuZFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0RHQpIHtcbiAgICAgIHRoaXMuZW5kRHQgPSBlbmRUaW1lc3RhbXA7XG4gICAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddID0gdGhpcy5lbmREdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3dhcHMgdGhlIHN0YXJ0IGRhdGUgYW5kIHRoZSBlbmQgZGF0ZSBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3dhcERhdGVzICgpIHtcbiAgICBsZXQgdGVtcCA9IHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZTtcbiAgICB0aGlzLmRhdGVSYW5nZS5zdGFydERhdGUgPSB0aGlzLmRhdGVSYW5nZS5lbmREYXRlO1xuICAgIHRoaXMuZGF0ZVJhbmdlLmVuZERhdGUgPSB0ZW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNzIHRoZSBkYXRlcmFuZ2Ugc2hvd24gYnkgdGhlIEZ1c2lvbkNoYXJ0cyB0aW1lIHNlcmllcyBjaGFydCBhbmQgdGhlIERhdGUgUmFuZ2UgQ2hvb3NlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3luY1JhbmdlICgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgZnJvbSBGdXNpb25DaGFydHMgd2hlbiBnaXZlbiBhIFVOSVggdGltZXN0YW1wXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZXN0YW1wIC0gQSBVTklYIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBkYXRlIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSBkYXRlIHN0cmluZyB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB0aW1lc3RhbXBcbiAgICovXG4gIGdldEZvcm1hdHRlZERhdGUgKHRpbWVzdGFtcCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldEZvcm1hdHRlZERhdGUodGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVU5JWCB0aW1lc3RhbXAgZnJvbSBGdXNpb25DaGFydHMgd2hlbiBnaXZlbiBhIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGRhdGVTdHJpbmcgLSBBIGRhdGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byBhIFVOSVggdGltZXN0YW1wXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBVTklYIHRpbWVzdGFtcCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBkYXRlIHN0cmluZ1xuICAgKi9cbiAgZ2V0VGltZXN0YW1wIChkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0VGltZXN0YW1wKGRhdGVTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIG9mIHRoZSBleHRlbnNpb24gKGUuZy4gY29zbWV0aWNzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIHZhcmlvdXMgZXh0ZW5zaW9uIG9wdGlvbnNcbiAgICovXG4gIHNldENvbmZpZyAoY29uZmlnT2JqKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmFibGUgb3B0aW9ucyBvZiB0aGUgZXh0ZW5zaW9uIChlLmcuIGNvc21ldGljcylcbiAgICogQHJldHVybiB7b2JqZWN0fSBjb25maWdPYmogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdmFyaW91cyBleHRlbnNpb24gb3B0aW9uc1xuICAgKi9cbiAgZ2V0Q29uZmlnICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsZW5kYXJWaXNpYmxlOiAnZmFsc2UnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdXNpb25jaGFydHMgbGlmZSBjeWNsZSBtZXRob2QgZm9yIGV4dGVuc2lvblxuICAgKi9cbiAgaW5pdCAocmVxdWlyZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG4gICAgcmVxdWlyZShbXG4gICAgICAneEF4aXMnLFxuICAgICAgJ3lBeGlzJyxcbiAgICAgICdncmFwaGljcycsXG4gICAgICAnY2hhcnQnLFxuICAgICAgJ2RhdGFzZXQnLFxuICAgICAgJ1Bsb3RNYW5hZ2VyJyxcbiAgICAgICdjYW52YXNDb25maWcnLFxuICAgICAgJ01hcmtlck1hbmFnZXInLFxuICAgICAgJ3JlYWN0aXZlTW9kZWwnLFxuICAgICAgJ2dsb2JhbFJlYWN0aXZlTW9kZWwnLFxuICAgICAgJ3NwYWNlTWFuYWdlckluc3RhbmNlJyxcbiAgICAgICdzbWFydExhYmVsJyxcbiAgICAgICdjaGFydEluc3RhbmNlJyxcbiAgICAgIGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHhBeGlzLFxuICAgICAgICAgICAgeUF4aXMsXG4gICAgICAgICAgICBncmFwaGljcyxcbiAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgIHBsb3RNYW5hZ2VyLFxuICAgICAgICAgICAgY2FudmFzQ29uZmlnLFxuICAgICAgICAgICAgbWFya2VyTWFuYWdlcixcbiAgICAgICAgICAgIHJlYWN0aXZlTW9kZWwsXG4gICAgICAgICAgICBnbG9iYWxSZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgc3BhY2VNYW5hZ2VySW5zdGFuY2UsXG4gICAgICAgICAgICBzbWFydExhYmVsKSB7XG4gICAgICAgIGluc3RhbmNlLnhBeGlzID0geEF4aXM7XG4gICAgICAgIGluc3RhbmNlLnlBeGlzID0geUF4aXM7XG4gICAgICAgIGluc3RhbmNlLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICAgIGluc3RhbmNlLmNoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIGluc3RhbmNlLmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgICBpbnN0YW5jZS5wbG90TWFuYWdlciA9IHBsb3RNYW5hZ2VyO1xuICAgICAgICBpbnN0YW5jZS5tYXJrZXJNYW5hZ2VyID0gbWFya2VyTWFuYWdlcjtcbiAgICAgICAgaW5zdGFuY2UuY2FudmFzQ29uZmlnID0gY2FudmFzQ29uZmlnO1xuICAgICAgICBpbnN0YW5jZS5yZWFjdGl2ZU1vZGVsID0gcmVhY3RpdmVNb2RlbDtcbiAgICAgICAgaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgICAgIGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlID0gc3BhY2VNYW5hZ2VySW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLnNtYXJ0TGFiZWwgPSBzbWFydExhYmVsO1xuICAgICAgfVxuICAgIF0pO1xuICAgIHRoaXMuc3BhY2VNYW5hZ2VySW5zdGFuY2UgPSBpbnN0YW5jZS5zcGFjZU1hbmFnZXJJbnN0YW5jZTtcbiAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsO1xuICAgIHRoaXMuc3RhcnREdCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLXN0YXJ0J107XG4gICAgdGhpcy5lbmREdCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddO1xuICAgIHRoaXMuc3RhcnREYXRhc2V0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLWFic29sdXRlLXJhbmdlLXN0YXJ0J107XG4gICAgdGhpcy5lbmREYXRhc2V0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLWFic29sdXRlLXJhbmdlLWVuZCddO1xuICAgIHRoaXMudG9vbGJhcnMgPSBbXTtcbiAgICB0aGlzLm1lYXN1cmVtZW50ID0ge307XG4gICAgdGhpcy50b29sYmFycy5wdXNoKHRoaXMuY3JlYXRlVG9vbGJhcigpKTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNyZWF0ZVRvb2xiYXIoKSk7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5kYXRlU3RhcnQsIHRoaXMuZGF0ZUVuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgY3JlYXRlVG9vbGJhciAoKSB7XG4gICAgdmFyIHRvb2xiYXIsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGZyb21EYXRlTGFiZWwsXG4gICAgICB0b0RhdGVMYWJlbCxcbiAgICAgIGdyb3VwLFxuICAgICAgZnJvbUZvcm1hdHRlZERhdGUsXG4gICAgICB0b0Zvcm1hdHRlZERhdGU7XG5cbiAgICBzZWxmLmZyb21EYXRlID0ge307XG4gICAgc2VsZi50b0RhdGUgPSB7fTtcblxuICAgIGZyb21Gb3JtYXR0ZWREYXRlID0gbmV3IERhdGUodGhpcy5zdGFydER0KS50b0xvY2FsZURhdGVTdHJpbmcoKTtcblxuICAgIHRvRm9ybWF0dGVkRGF0ZSA9IG5ldyBEYXRlKHRoaXMuZW5kRHQpLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuXG4gICAgdG9vbGJhciA9IG5ldyB0aGlzLkhvcml6b250YWxUb29sYmFyKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIGJvcmRlclRoaWNrbmVzczogMFxuICAgIH0pO1xuXG4gICAgZ3JvdXAgPSBuZXcgdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIGdyb3VwLnNldENvbmZpZyh7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICB9KTtcblxuICAgIGZyb21EYXRlTGFiZWwgPSBuZXcgdGhpcy50b29sYm94LkxhYmVsKCdGcm9tOicsIHtcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyXG4gICAgfSwge1xuICAgICAgdGV4dDoge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICdmb250LXNpemUnOiAnMTUnLFxuICAgICAgICAgICdmb250RmFtaWx5JzogJ015cmlhZFBybydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2VsZi5mcm9tRGF0ZSA9IG5ldyB0aGlzLnRvb2xib3guSW5wdXRUZXh0Qm94U3ltYm9sKHtcbiAgICAgIHdpZHRoOiAxMjAsXG4gICAgICBoZWlnaHQ6IDI1XG4gICAgfSwge1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0sIHtcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAwLFxuICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiBmcm9tRm9ybWF0dGVkRGF0ZVxuICAgIH0pO1xuXG4gICAgdG9EYXRlTGFiZWwgPSBuZXcgdGhpcy50b29sYm94LkxhYmVsKCdUbzonLCB7XG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBwYXBlcjogdGhpcy5ncmFwaGljcy5wYXBlclxuICAgIH0sIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAnZm9udC1zaXplJzogJzE1JyxcbiAgICAgICAgICAnZm9udEZhbWlseSc6ICdNeXJpYWRQcm8nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNlbGYudG9EYXRlID0gbmV3IHRoaXMudG9vbGJveC5JbnB1dFRleHRCb3hTeW1ib2woe1xuICAgICAgd2lkdGg6IDEyMCxcbiAgICAgIGhlaWdodDogMjVcbiAgICB9LCB7XG4gICAgICBwYXBlcjogdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgc21hcnRMYWJlbDogdGhpcy5zbWFydExhYmVsLFxuICAgICAgY2hhcnRDb250YWluZXI6IHRoaXMuZ3JhcGhpY3MuY29udGFpbmVyXG4gICAgfSwge1xuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBzdHJva2U6ICdyZ2JhKDEwMiwxMDIsMTAyLDAuNSknLFxuICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDAsXG4gICAgICBidG5UZXh0U3R5bGU6IHtcbiAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICB9LFxuICAgICAgbGFiZWw6IHRvRm9ybWF0dGVkRGF0ZVxuICAgIH0pO1xuXG4gICAgc2VsZi5mcm9tRGF0ZS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgIGNsaWNrOiB7XG4gICAgICAgIGZuOiBzZWxmLmZyb21EYXRlLmVkaXRcbiAgICAgIH0sXG4gICAgICB0ZXh0T25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZnJvbURhdGUuYmx1cigpO1xuICAgICAgICBzZWxmLnN0YXJ0RGF0ZSA9IHNlbGYuZnJvbURhdGUuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWxmLmZyb21EYXRlLmdldFRleHQoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWxmLnRvRGF0ZS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgIGNsaWNrOiB7XG4gICAgICAgIGZuOiBzZWxmLnRvRGF0ZS5lZGl0XG4gICAgICB9LFxuICAgICAgdGV4dE9uQmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnRvRGF0ZS5ibHVyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlbGYudG9EYXRlLmdldFRleHQoKSk7XG4gICAgICAgIHNlbGYuZW5kRGF0ZSA9IHNlbGYudG9EYXRlLmdldFRleHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuU3ltYm9sU3RvcmUucmVnaXN0ZXIoJ3RleHRCb3hJY29uJywgZnVuY3Rpb24gKHgsIHksIHJhZCwgdywgaCwgcGFkWCwgcGFkWSkge1xuICAgICAgdmFyIHgxID0geCAtIHcgLyAyICsgcGFkWCAvIDIsXG4gICAgICAgIHgyID0geCArIHcgLyAyIC0gcGFkWCAvIDIsXG4gICAgICAgIHkxID0geSAtIGggLyAyICsgcGFkWSAvIDIsXG4gICAgICAgIHkyID0geSArIGggLyAyIC0gcGFkWSAvIDI7XG5cbiAgICAgIHJldHVybiBbJ00nLCB4MSwgeTEsICdMJywgeDIsIHkxLCAnTCcsIHgyLCB5MiwgJ0wnLCB4MSwgeTIsICdaJ107XG4gICAgfSk7XG5cbiAgICBncm91cC5hZGRTeW1ib2woZnJvbURhdGVMYWJlbCk7XG4gICAgZ3JvdXAuYWRkU3ltYm9sKHNlbGYuZnJvbURhdGUpO1xuICAgIGdyb3VwLmFkZFN5bWJvbCh0b0RhdGVMYWJlbCk7XG4gICAgZ3JvdXAuYWRkU3ltYm9sKHNlbGYudG9EYXRlKTtcbiAgICB0b29sYmFyLmFkZENvbXBvbmVudChncm91cCk7XG4gICAgcmV0dXJuIHRvb2xiYXI7XG4gIH07XG5cbiAgZ2V0TG9naWNhbFNwYWNlIChhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgYXZhaWxhYmxlV2lkdGggLz0gMjtcbiAgICB2YXIgbG9naWNhbFNwYWNlLFxuICAgICAgd2lkdGggPSAwLFxuICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgIGksXG4gICAgICBsbjtcblxuICAgIGZvciAoaSA9IDAsIGxuID0gdGhpcy50b29sYmFycy5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICBsb2dpY2FsU3BhY2UgPSB0aGlzLnRvb2xiYXJzW2ldLmdldExvZ2ljYWxTcGFjZSgpO1xuICAgICAgd2lkdGggPSBNYXRoLm1heChsb2dpY2FsU3BhY2Uud2lkdGgsIHdpZHRoKTtcbiAgICAgIGhlaWdodCArPSBsb2dpY2FsU3BhY2UuaGVpZ2h0O1xuICAgICAgdGhpcy50b29sYmFyc1tpXS53aWR0aCA9IGxvZ2ljYWxTcGFjZS53aWR0aDtcbiAgICAgIHRoaXMudG9vbGJhcnNbaV0uaGVpZ2h0ID0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICB9XG4gICAgaGVpZ2h0ICs9IHRoaXMucGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoID4gYXZhaWxhYmxlV2lkdGggPyAwIDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCA/IDAgOiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIHBsYWNlSW5DYW52YXMgKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnBhZGRpbmcgPSA1O1xuICAgIHNlbGYuc3BhY2VNYW5hZ2VySW5zdGFuY2UuYWRkKFt7XG4gICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVG9vbEJveEV4dCc7XG4gICAgICB9LFxuICAgICAgcmVmOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbJzAnXTtcbiAgICAgIH0sXG4gICAgICBzZWxmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSxcbiAgICAgIHByaW9yaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSxcbiAgICAgIGxheW91dDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqLmlubGluZTtcbiAgICAgIH0sXG4gICAgICBvcmllbnRhdGlvbjogW3tcbiAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouaG9yaXpvbnRhbDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IFt7XG4gICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai50b3A7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbGlnbm1lbnQ6IFt7XG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmoubGVmdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDb21wb25lbnRHcm91cCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRMb2dpY2FsU3BhY2UocGFyZW50LmdldFdpZHRoKCksIHBhcmVudC5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dKTtcbiAgfTtcblxuICBzZXREcmF3aW5nQ29uZmlndXJhdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVzID0gdGhpcy5tZWFzdXJlbWVudDtcbiAgICBtZXMueCA9IHg7XG4gICAgbWVzLnkgPSB5O1xuICAgIG1lcy53aWR0aCA9IHdpZHRoO1xuICAgIG1lcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnBhcmVudEdyb3VwID0gZ3JvdXA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBkcmF3ICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBncm91cCkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IHRoaXMubWVhc3VyZW1lbnQsXG4gICAgICB0b29sYmFycyA9IHRoaXMudG9vbGJhcnMsXG4gICAgICBsbixcbiAgICAgIGksXG4gICAgICB0b29sYmFyLFxuICAgICAgbW9kZWwgPSB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwsXG4gICAgICBzZWxmID0gdGhpcztcbiAgICBjb25zb2xlLmxvZyhtb2RlbCk7XG4gICAgeCA9IHggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LnggOiB4O1xuICAgIHkgPSB5ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC55IDogeTtcbiAgICB3aWR0aCA9IHdpZHRoID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC53aWR0aCA6IHdpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQuaGVpZ2h0IDogaGVpZ2h0O1xuICAgIGdyb3VwID0gZ3JvdXAgPT09IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50R3JvdXAgOiBncm91cDtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICBmb3IgKGkgPSAwLCBsbiA9IHRvb2xiYXJzLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgdG9vbGJhciA9IHRvb2xiYXJzW2ldO1xuICAgICAgICB0b29sYmFyLmRyYXcoeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWwub25Qcm9wc0NoYW5nZShbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLXN0YXJ0JywgJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgc2VsZi5mcm9tRGF0ZS5ibHVyKG5ldyBEYXRlKHN0YXJ0WzFdKS50b0xvY2FsZURhdGVTdHJpbmcoKSk7XG4gICAgICBzZWxmLnRvRGF0ZS5ibHVyKG5ldyBEYXRlKGVuZFsxXSkudG9Mb2NhbGVEYXRlU3RyaW5nKCkpO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IERhdGVSYW5nZTtcbn0gZWxzZSB7XG4gIHdpbmRvdy5TdGFuZGFyZFBlcmlvZCA9IERhdGVSYW5nZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ZjdHMtZXh0LWRhdGVyYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9