/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(2);
	
	window.dr = new DateRange();
	
	;(function (env, factory) {
	  if (typeof module === 'object' && module.exports) {
	    module.exports = env.document
	       ? factory(env) : function (win) {
	         if (!win.document) {
	           throw new Error('Window with document not present');
	         }
	         return factory(win, true);
	       };
	  } else {
	    env.DateRangeChooser = factory(env, true);
	  }
	})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {
	  var FC = _window.FusionCharts;
	  FC.register('extension', ['private', 'DateRangeChooser', function () {
	    FC.registerComponent('extensions', 'DateRangeChooser', DateRange({FusionCharts: FC}));
	  }]);
	});


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	
	module.exports = function (dep) {
	  class DateRange {
	    constructor () {
	      /**
	       * @private
	       */
	
	      this.startDt = 0;
	      this.endDt = 0;
	      this.startDataset = 0;
	      this.endDataset = 0;
	      this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');
	      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	      this.ComponentGroup = this.toolbox.ComponentGroup;
	      this.SymbolStore = this.toolbox.SymbolStore;
	      this.startText = {
	        attr: function () {}
	      };
	      this.endText = {
	        attr: function () {}
	      };
	    }
	
	    /**
	     * An object representing the start and end dates.
	     * @type {DateRange.range}
	     */
	    get startDate () {
	      return this.startDt;
	    }
	
	    set startDate (startDt) {
	      let startTimestamp = +new Date(startDt);
	      if (startTimestamp <= this.endDt) {
	        this.startDt = startTimestamp;
	        this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;
	      }
	    }
	
	    get endDate () {
	      return this.endDt;
	    }
	
	    set endDate (endDt) {
	      let endTimestamp = +new Date(endDt);
	      if (endTimestamp >= this.startDt) {
	        this.endDt = endTimestamp;
	        this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;
	      }
	    }
	
	    /**
	     * Swaps the start date and the end date of the date range
	     * @private
	     */
	    swapDates () {
	      let temp = this.dateRange.startDate;
	      this.dateRange.startDate = this.dateRange.endDate;
	      this.dateRange.endDate = temp;
	    }
	
	    /**
	     * Syncs the daterange shown by the FusionCharts time series chart and the Date Range Chooser
	     * @private
	     */
	    syncRange () {}
	
	    /**
	     * Returns a formatted date string from FusionCharts when given a UNIX timestamp
	     * @param  {number} timestamp - A UNIX timestamp to be converted to a date string
	     * @return {string} - A date string which is equivalent to the given timestamp
	     */
	    getFormattedDate (timestamp) {
	      return this.chart.getFormattedDate(timestamp);
	    }
	
	    /**
	     * Returns a UNIX timestamp from FusionCharts when given a formatted date string
	     * @param  {string} dateString - A date string to be converted to a UNIX timestamp
	     * @return {number} A UNIX timestamp which is equivalent to the given date string
	     */
	    getTimestamp (dateString) {
	      return this.chart.getTimestamp(dateString);
	    }
	
	    /**
	     * Sets the configurable options of the extension (e.g. cosmetics)
	     * @param {Object} configObj The configuration object containing various extension options
	     */
	    setConfig (configObj) {}
	
	    /**
	     * Gets the configurable options of the extension (e.g. cosmetics)
	     * @return {object} configObj The configuration object containing various extension options
	     */
	    getConfig () {
	      return {
	        calendarVisible: 'false'
	      };
	    }
	
	    /**
	     * Fusioncharts life cycle method for extension
	     */
	    init (require) {
	      var instance = this;
	      require([
	        'xAxis',
	        'yAxis',
	        'graphics',
	        'chart',
	        'dataset',
	        'PlotManager',
	        'canvasConfig',
	        'MarkerManager',
	        'reactiveModel',
	        'globalReactiveModel',
	        'spaceManagerInstance',
	        'smartLabel',
	        'chartInstance',
	        function (
	              xAxis,
	              yAxis,
	              graphics,
	              chart,
	              dataset,
	              plotManager,
	              canvasConfig,
	              markerManager,
	              reactiveModel,
	              globalReactiveModel,
	              spaceManagerInstance,
	              smartLabel) {
	          instance.xAxis = xAxis;
	          instance.yAxis = yAxis;
	          instance.graphics = graphics;
	          instance.chart = chart;
	          instance.dataset = dataset;
	          instance.plotManager = plotManager;
	          instance.markerManager = markerManager;
	          instance.canvasConfig = canvasConfig;
	          instance.reactiveModel = reactiveModel;
	          instance.globalReactiveModel = globalReactiveModel;
	          instance.spaceManagerInstance = spaceManagerInstance;
	          instance.smartLabel = smartLabel;
	        }
	      ]);
	      this.spaceManagerInstance = instance.spaceManagerInstance;
	      this.globalReactiveModel = instance.globalReactiveModel;
	      this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	      this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	      this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	      this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	      this.toolbars = [];
	      this.measurement = {};
	      this.toolbars.push(this.createToolbar());
	      // console.log(this.createToolbar());
	      // console.log(this.dateStart, this.dateEnd);
	      return this;
	    };
	
	    createToolbar () {
	      var toolbar,
	        self = this,
	        fromDateLabel,
	        toDateLabel,
	        group,
	        fromFormattedDate,
	        toFormattedDate;
	
	      self.fromDate = {};
	      self.toDate = {};
	
	      fromFormattedDate = new Date(this.startDt).toLocaleDateString();
	
	      toFormattedDate = new Date(this.endDt).toLocaleDateString();
	
	      toolbar = new this.HorizontalToolbar({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      toolbar.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      group = new this.toolbox.ComponentGroup({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      group.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      fromDateLabel = new this.toolbox.Label('From:', {
	        smartLabel: this.smartLabel,
	        paper: this.graphics.paper
	      }, {
	        text: {
	          style: {
	            'font-size': '15',
	            'font-family': 'MyriadPro'
	          }
	        }
	      });
	
	      self.fromDate = new this.toolbox.InputTextBoxSymbol({
	        width: 80,
	        height: 22
	      }, {
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        margin: {
	          right: 22
	        },
	        btnTextStyle: {
	          fontSize: 14
	        },
	        label: fromFormattedDate
	      });
	
	      toDateLabel = new this.toolbox.Label('To:', {
	        smartLabel: this.smartLabel,
	        paper: this.graphics.paper
	      }, {
	        text: {
	          style: {
	            'font-size': '15',
	            'font-family': 'MyriadPro'
	          }
	        }
	      });
	
	      self.toDate = new this.toolbox.InputTextBoxSymbol({
	        width: 80,
	        height: 22
	      }, {
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        btnTextStyle: {
	          fontSize: 14
	        },
	        label: toFormattedDate
	      });
	
	      self.fromDate.attachEventHandlers({
	        click: {
	          fn: self.fromDate.edit
	        },
	        textOnBlur: function () {
	          self.fromDate.blur();
	          self.startDate = self.fromDate.getText();
	          console.log(self.fromDate.getText());
	        }
	      });
	
	      self.toDate.attachEventHandlers({
	        click: {
	          fn: self.toDate.edit
	        },
	        textOnBlur: function () {
	          self.toDate.blur();
	          console.log(self.toDate.getText());
	          self.endDate = self.toDate.getText();
	        }
	      });
	
	      this.SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
	        var x1 = x - w / 2 + padX / 2,
	          x2 = x + w / 2 - padX / 2,
	          y1 = y - h / 2 + padY / 2,
	          y2 = y + h / 2 - padY / 2;
	
	        return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
	      });
	
	      group.addSymbol(fromDateLabel);
	      group.addSymbol(self.fromDate);
	      group.addSymbol(toDateLabel);
	      group.addSymbol(self.toDate);
	      toolbar.addComponent(group);
	      return toolbar;
	    };
	
	    getLogicalSpace (availableWidth, availableHeight) {
	      availableWidth /= 2;
	      var logicalSpace,
	        width = 0,
	        height = 0,
	        i,
	        ln;
	
	      for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	        logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
	        width = Math.max(logicalSpace.width, width);
	        height += logicalSpace.height;
	        this.toolbars[i].width = logicalSpace.width;
	        this.toolbars[i].height = logicalSpace.height;
	      }
	      height += this.padding;
	      return {
	        width: width,
	        height: height
	      };
	    };
	
	    placeInCanvas () {
	      var self = this;
	      self.padding = 5;
	      self.spaceManagerInstance.add([{
	        name: function () {
	          return 'ToolBoxExt';
	        },
	        ref: function (obj) {
	          return obj['0'];
	        },
	        self: function () {
	          return self;
	        },
	        priority: function () {
	          return 2;
	        },
	        layout: function (obj) {
	          return obj.inline;
	        },
	        orientation: [{
	          type: function (obj) {
	            return obj.horizontal;
	          },
	          position: [{
	            type: function (obj) {
	              return obj.top;
	            },
	            alignment: [{
	              type: function (obj) {
	                return obj.right;
	              },
	              dimensions: [function () {
	                var parent = this.getParentComponentGroup();
	                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	              }]
	            }]
	          }]
	        }]
	      }]);
	    };
	
	    setDrawingConfiguration (x, y, width, height, group) {
	      var mes = this.measurement;
	      mes.x = x;
	      mes.y = y;
	      mes.width = width;
	      mes.height = height;
	
	      this.parentGroup = group;
	
	      return this;
	    };
	
	    draw (x, y, width, height, group) {
	      var measurement = this.measurement,
	        toolbars = this.toolbars,
	        ln,
	        i,
	        toolbar,
	        model = this.globalReactiveModel,
	        self = this;
	      console.log(model);
	      x = x === undefined ? measurement.x : x;
	      y = y === undefined ? measurement.y : y;
	      width = width === undefined ? measurement.width : width;
	      height = height === undefined ? measurement.height : height;
	      group = group === undefined ? this.parentGroup : group;
	      if (width && height) {
	        for (i = 0, ln = toolbars.length; i < ln; i++) {
	          toolbar = toolbars[i];
	          toolbar.draw(x, y, group);
	        }
	      }
	
	      model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'], function (start, end) {
	        self.fromDate.blur(new Date(start[1]).toLocaleDateString());
	        self.toDate.blur(new Date(end[1]).toLocaleDateString());
	      });
	    };
	  }
	  return DateRange;
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjIzMjY4MmZmMDJkZjE5NzVmN2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsdUVBQXNFLGlCQUFpQjtBQUN2RixJQUFHO0FBQ0gsRUFBQzs7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2YsY0FBYTtBQUNiLFlBQVc7QUFDWCxVQUFTO0FBQ1QsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJmY3RzLWV4dC1kYXRlcmFuZ2UtZXM2Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGYyMzI2ODJmZjAyZGYxOTc1ZjdmIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgRGF0ZVJhbmdlID0gcmVxdWlyZSgnLi9mY3RzLWV4dC1kYXRlcmFuZ2UnKTtcblxud2luZG93LmRyID0gbmV3IERhdGVSYW5nZSgpO1xuXG47KGZ1bmN0aW9uIChlbnYsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnYuZG9jdW1lbnRcbiAgICAgICA/IGZhY3RvcnkoZW52KSA6IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAgICAgIGlmICghd2luLmRvY3VtZW50KSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IHdpdGggZG9jdW1lbnQgbm90IHByZXNlbnQnKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWN0b3J5KHdpbiwgdHJ1ZSk7XG4gICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbnYuRGF0ZVJhbmdlQ2hvb3NlciA9IGZhY3RvcnkoZW52LCB0cnVlKTtcbiAgfVxufSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoX3dpbmRvdywgd2luZG93RXhpc3RzKSB7XG4gIHZhciBGQyA9IF93aW5kb3cuRnVzaW9uQ2hhcnRzO1xuICBGQy5yZWdpc3RlcignZXh0ZW5zaW9uJywgWydwcml2YXRlJywgJ0RhdGVSYW5nZUNob29zZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgRkMucmVnaXN0ZXJDb21wb25lbnQoJ2V4dGVuc2lvbnMnLCAnRGF0ZVJhbmdlQ2hvb3NlcicsIERhdGVSYW5nZSh7RnVzaW9uQ2hhcnRzOiBGQ30pKTtcbiAgfV0pO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgRGF0ZVJhbmdlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlcCkge1xuICBjbGFzcyBEYXRlUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLnN0YXJ0RHQgPSAwO1xuICAgICAgdGhpcy5lbmREdCA9IDA7XG4gICAgICB0aGlzLnN0YXJ0RGF0YXNldCA9IDA7XG4gICAgICB0aGlzLmVuZERhdGFzZXQgPSAwO1xuICAgICAgdGhpcy50b29sYm94ID0gZGVwLkZ1c2lvbkNoYXJ0cy5nZXRDb21wb25lbnQoJ2FwaScsICd0b29sYm94Jyk7XG4gICAgICB0aGlzLkhvcml6b250YWxUb29sYmFyID0gdGhpcy50b29sYm94Lkhvcml6b250YWxUb29sYmFyO1xuICAgICAgdGhpcy5Db21wb25lbnRHcm91cCA9IHRoaXMudG9vbGJveC5Db21wb25lbnRHcm91cDtcbiAgICAgIHRoaXMuU3ltYm9sU3RvcmUgPSB0aGlzLnRvb2xib3guU3ltYm9sU3RvcmU7XG4gICAgICB0aGlzLnN0YXJ0VGV4dCA9IHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgICB0aGlzLmVuZFRleHQgPSB7XG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMuXG4gICAgICogQHR5cGUge0RhdGVSYW5nZS5yYW5nZX1cbiAgICAgKi9cbiAgICBnZXQgc3RhcnREYXRlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0RHQ7XG4gICAgfVxuXG4gICAgc2V0IHN0YXJ0RGF0ZSAoc3RhcnREdCkge1xuICAgICAgbGV0IHN0YXJ0VGltZXN0YW1wID0gK25ldyBEYXRlKHN0YXJ0RHQpO1xuICAgICAgaWYgKHN0YXJ0VGltZXN0YW1wIDw9IHRoaXMuZW5kRHQpIHtcbiAgICAgICAgdGhpcy5zdGFydER0ID0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXSA9IHRoaXMuc3RhcnREdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZW5kRGF0ZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmREdDtcbiAgICB9XG5cbiAgICBzZXQgZW5kRGF0ZSAoZW5kRHQpIHtcbiAgICAgIGxldCBlbmRUaW1lc3RhbXAgPSArbmV3IERhdGUoZW5kRHQpO1xuICAgICAgaWYgKGVuZFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0RHQpIHtcbiAgICAgICAgdGhpcy5lbmREdCA9IGVuZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1lbmQnXSA9IHRoaXMuZW5kRHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgdGhlIHN0YXJ0IGRhdGUgYW5kIHRoZSBlbmQgZGF0ZSBvZiB0aGUgZGF0ZSByYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3dhcERhdGVzICgpIHtcbiAgICAgIGxldCB0ZW1wID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlO1xuICAgICAgdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlID0gdGhpcy5kYXRlUmFuZ2UuZW5kRGF0ZTtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlLmVuZERhdGUgPSB0ZW1wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN5bmNzIHRoZSBkYXRlcmFuZ2Ugc2hvd24gYnkgdGhlIEZ1c2lvbkNoYXJ0cyB0aW1lIHNlcmllcyBjaGFydCBhbmQgdGhlIERhdGUgUmFuZ2UgQ2hvb3NlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3luY1JhbmdlICgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGZyb20gRnVzaW9uQ2hhcnRzIHdoZW4gZ2l2ZW4gYSBVTklYIHRpbWVzdGFtcFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZXN0YW1wIC0gQSBVTklYIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBkYXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gLSBBIGRhdGUgc3RyaW5nIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHRpbWVzdGFtcFxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlZERhdGUgKHRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0Rm9ybWF0dGVkRGF0ZSh0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBVTklYIHRpbWVzdGFtcCBmcm9tIEZ1c2lvbkNoYXJ0cyB3aGVuIGdpdmVuIGEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBkYXRlU3RyaW5nIC0gQSBkYXRlIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBVTklYIHRpbWVzdGFtcFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSBVTklYIHRpbWVzdGFtcCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBkYXRlIHN0cmluZ1xuICAgICAqL1xuICAgIGdldFRpbWVzdGFtcCAoZGF0ZVN0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0VGltZXN0YW1wKGRhdGVTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIG9mIHRoZSBleHRlbnNpb24gKGUuZy4gY29zbWV0aWNzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdmFyaW91cyBleHRlbnNpb24gb3B0aW9uc1xuICAgICAqL1xuICAgIHNldENvbmZpZyAoY29uZmlnT2JqKSB7fVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29uZmlndXJhYmxlIG9wdGlvbnMgb2YgdGhlIGV4dGVuc2lvbiAoZS5nLiBjb3NtZXRpY3MpXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBjb25maWdPYmogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdmFyaW91cyBleHRlbnNpb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGdldENvbmZpZyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxlbmRhclZpc2libGU6ICdmYWxzZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVzaW9uY2hhcnRzIGxpZmUgY3ljbGUgbWV0aG9kIGZvciBleHRlbnNpb25cbiAgICAgKi9cbiAgICBpbml0IChyZXF1aXJlKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgcmVxdWlyZShbXG4gICAgICAgICd4QXhpcycsXG4gICAgICAgICd5QXhpcycsXG4gICAgICAgICdncmFwaGljcycsXG4gICAgICAgICdjaGFydCcsXG4gICAgICAgICdkYXRhc2V0JyxcbiAgICAgICAgJ1Bsb3RNYW5hZ2VyJyxcbiAgICAgICAgJ2NhbnZhc0NvbmZpZycsXG4gICAgICAgICdNYXJrZXJNYW5hZ2VyJyxcbiAgICAgICAgJ3JlYWN0aXZlTW9kZWwnLFxuICAgICAgICAnZ2xvYmFsUmVhY3RpdmVNb2RlbCcsXG4gICAgICAgICdzcGFjZU1hbmFnZXJJbnN0YW5jZScsXG4gICAgICAgICdzbWFydExhYmVsJyxcbiAgICAgICAgJ2NoYXJ0SW5zdGFuY2UnLFxuICAgICAgICBmdW5jdGlvbiAoXG4gICAgICAgICAgICAgIHhBeGlzLFxuICAgICAgICAgICAgICB5QXhpcyxcbiAgICAgICAgICAgICAgZ3JhcGhpY3MsXG4gICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgICBwbG90TWFuYWdlcixcbiAgICAgICAgICAgICAgY2FudmFzQ29uZmlnLFxuICAgICAgICAgICAgICBtYXJrZXJNYW5hZ2VyLFxuICAgICAgICAgICAgICByZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgICBnbG9iYWxSZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgICBzcGFjZU1hbmFnZXJJbnN0YW5jZSxcbiAgICAgICAgICAgICAgc21hcnRMYWJlbCkge1xuICAgICAgICAgIGluc3RhbmNlLnhBeGlzID0geEF4aXM7XG4gICAgICAgICAgaW5zdGFuY2UueUF4aXMgPSB5QXhpcztcbiAgICAgICAgICBpbnN0YW5jZS5ncmFwaGljcyA9IGdyYXBoaWNzO1xuICAgICAgICAgIGluc3RhbmNlLmNoYXJ0ID0gY2hhcnQ7XG4gICAgICAgICAgaW5zdGFuY2UuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICAgICAgaW5zdGFuY2UucGxvdE1hbmFnZXIgPSBwbG90TWFuYWdlcjtcbiAgICAgICAgICBpbnN0YW5jZS5tYXJrZXJNYW5hZ2VyID0gbWFya2VyTWFuYWdlcjtcbiAgICAgICAgICBpbnN0YW5jZS5jYW52YXNDb25maWcgPSBjYW52YXNDb25maWc7XG4gICAgICAgICAgaW5zdGFuY2UucmVhY3RpdmVNb2RlbCA9IHJlYWN0aXZlTW9kZWw7XG4gICAgICAgICAgaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgICAgICAgaW5zdGFuY2Uuc3BhY2VNYW5hZ2VySW5zdGFuY2UgPSBzcGFjZU1hbmFnZXJJbnN0YW5jZTtcbiAgICAgICAgICBpbnN0YW5jZS5zbWFydExhYmVsID0gc21hcnRMYWJlbDtcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICB0aGlzLnNwYWNlTWFuYWdlckluc3RhbmNlID0gaW5zdGFuY2Uuc3BhY2VNYW5hZ2VySW5zdGFuY2U7XG4gICAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsO1xuICAgICAgdGhpcy5zdGFydER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXTtcbiAgICAgIHRoaXMuZW5kRHQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1lbmQnXTtcbiAgICAgIHRoaXMuc3RhcnREYXRhc2V0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLWFic29sdXRlLXJhbmdlLXN0YXJ0J107XG4gICAgICB0aGlzLmVuZERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2UtZW5kJ107XG4gICAgICB0aGlzLnRvb2xiYXJzID0gW107XG4gICAgICB0aGlzLm1lYXN1cmVtZW50ID0ge307XG4gICAgICB0aGlzLnRvb2xiYXJzLnB1c2godGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5kYXRlU3RhcnQsIHRoaXMuZGF0ZUVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY3JlYXRlVG9vbGJhciAoKSB7XG4gICAgICB2YXIgdG9vbGJhcixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGZyb21EYXRlTGFiZWwsXG4gICAgICAgIHRvRGF0ZUxhYmVsLFxuICAgICAgICBncm91cCxcbiAgICAgICAgZnJvbUZvcm1hdHRlZERhdGUsXG4gICAgICAgIHRvRm9ybWF0dGVkRGF0ZTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZSA9IHt9O1xuICAgICAgc2VsZi50b0RhdGUgPSB7fTtcblxuICAgICAgZnJvbUZvcm1hdHRlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLnN0YXJ0RHQpLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuXG4gICAgICB0b0Zvcm1hdHRlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmVuZER0KS50b0xvY2FsZURhdGVTdHJpbmcoKTtcblxuICAgICAgdG9vbGJhciA9IG5ldyB0aGlzLkhvcml6b250YWxUb29sYmFyKHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICAgIH0pO1xuXG4gICAgICBncm91cCA9IG5ldyB0aGlzLnRvb2xib3guQ29tcG9uZW50R3JvdXAoe1xuICAgICAgICBwYXBlcjogdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgICAgY2hhcnRDb250YWluZXI6IHRoaXMuZ3JhcGhpY3MuY29udGFpbmVyXG4gICAgICB9KTtcblxuICAgICAgZ3JvdXAuc2V0Q29uZmlnKHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICAgIH0pO1xuXG4gICAgICBmcm9tRGF0ZUxhYmVsID0gbmV3IHRoaXMudG9vbGJveC5MYWJlbCgnRnJvbTonLCB7XG4gICAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXJcbiAgICAgIH0sIHtcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzE1JyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdNeXJpYWRQcm8nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZSA9IG5ldyB0aGlzLnRvb2xib3guSW5wdXRUZXh0Qm94U3ltYm9sKHtcbiAgICAgICAgd2lkdGg6IDgwLFxuICAgICAgICBoZWlnaHQ6IDIyXG4gICAgICB9LCB7XG4gICAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgICAgc21hcnRMYWJlbDogdGhpcy5zbWFydExhYmVsLFxuICAgICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICAgIH0sIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJ3JnYmEoMTAyLDEwMiwxMDIsMC41KScsXG4gICAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICByaWdodDogMjJcbiAgICAgICAgfSxcbiAgICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiBmcm9tRm9ybWF0dGVkRGF0ZVxuICAgICAgfSk7XG5cbiAgICAgIHRvRGF0ZUxhYmVsID0gbmV3IHRoaXMudG9vbGJveC5MYWJlbCgnVG86Jywge1xuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyXG4gICAgICB9LCB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxNScsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnTXlyaWFkUHJvJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYudG9EYXRlID0gbmV3IHRoaXMudG9vbGJveC5JbnB1dFRleHRCb3hTeW1ib2woe1xuICAgICAgICB3aWR0aDogODAsXG4gICAgICAgIGhlaWdodDogMjJcbiAgICAgIH0sIHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIGJ0blRleHRTdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogdG9Gb3JtYXR0ZWREYXRlXG4gICAgICB9KTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICBmbjogc2VsZi5mcm9tRGF0ZS5lZGl0XG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLmZyb21EYXRlLmJsdXIoKTtcbiAgICAgICAgICBzZWxmLnN0YXJ0RGF0ZSA9IHNlbGYuZnJvbURhdGUuZ2V0VGV4dCgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKHNlbGYuZnJvbURhdGUuZ2V0VGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYudG9EYXRlLmF0dGFjaEV2ZW50SGFuZGxlcnMoe1xuICAgICAgICBjbGljazoge1xuICAgICAgICAgIGZuOiBzZWxmLnRvRGF0ZS5lZGl0XG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnRvRGF0ZS5ibHVyKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coc2VsZi50b0RhdGUuZ2V0VGV4dCgpKTtcbiAgICAgICAgICBzZWxmLmVuZERhdGUgPSBzZWxmLnRvRGF0ZS5nZXRUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLlN5bWJvbFN0b3JlLnJlZ2lzdGVyKCd0ZXh0Qm94SWNvbicsIGZ1bmN0aW9uICh4LCB5LCByYWQsIHcsIGgsIHBhZFgsIHBhZFkpIHtcbiAgICAgICAgdmFyIHgxID0geCAtIHcgLyAyICsgcGFkWCAvIDIsXG4gICAgICAgICAgeDIgPSB4ICsgdyAvIDIgLSBwYWRYIC8gMixcbiAgICAgICAgICB5MSA9IHkgLSBoIC8gMiArIHBhZFkgLyAyLFxuICAgICAgICAgIHkyID0geSArIGggLyAyIC0gcGFkWSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIFsnTScsIHgxLCB5MSwgJ0wnLCB4MiwgeTEsICdMJywgeDIsIHkyLCAnTCcsIHgxLCB5MiwgJ1onXTtcbiAgICAgIH0pO1xuXG4gICAgICBncm91cC5hZGRTeW1ib2woZnJvbURhdGVMYWJlbCk7XG4gICAgICBncm91cC5hZGRTeW1ib2woc2VsZi5mcm9tRGF0ZSk7XG4gICAgICBncm91cC5hZGRTeW1ib2wodG9EYXRlTGFiZWwpO1xuICAgICAgZ3JvdXAuYWRkU3ltYm9sKHNlbGYudG9EYXRlKTtcbiAgICAgIHRvb2xiYXIuYWRkQ29tcG9uZW50KGdyb3VwKTtcbiAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH07XG5cbiAgICBnZXRMb2dpY2FsU3BhY2UgKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgIGF2YWlsYWJsZVdpZHRoIC89IDI7XG4gICAgICB2YXIgbG9naWNhbFNwYWNlLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGxuO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsbiA9IHRoaXMudG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICBsb2dpY2FsU3BhY2UgPSB0aGlzLnRvb2xiYXJzW2ldLmdldExvZ2ljYWxTcGFjZShhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heChsb2dpY2FsU3BhY2Uud2lkdGgsIHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ICs9IGxvZ2ljYWxTcGFjZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMudG9vbGJhcnNbaV0ud2lkdGggPSBsb2dpY2FsU3BhY2Uud2lkdGg7XG4gICAgICAgIHRoaXMudG9vbGJhcnNbaV0uaGVpZ2h0ID0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGhlaWdodCArPSB0aGlzLnBhZGRpbmc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBwbGFjZUluQ2FudmFzICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYucGFkZGluZyA9IDU7XG4gICAgICBzZWxmLnNwYWNlTWFuYWdlckluc3RhbmNlLmFkZChbe1xuICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICdUb29sQm94RXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialsnMCddO1xuICAgICAgICB9LFxuICAgICAgICBzZWxmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouaW5saW5lO1xuICAgICAgICB9LFxuICAgICAgICBvcmllbnRhdGlvbjogW3tcbiAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogW3tcbiAgICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai50b3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5yaWdodDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGltZW5zaW9uczogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDb21wb25lbnRHcm91cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldExvZ2ljYWxTcGFjZShwYXJlbnQuZ2V0V2lkdGgoKSwgcGFyZW50LmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH1dKTtcbiAgICB9O1xuXG4gICAgc2V0RHJhd2luZ0NvbmZpZ3VyYXRpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdyb3VwKSB7XG4gICAgICB2YXIgbWVzID0gdGhpcy5tZWFzdXJlbWVudDtcbiAgICAgIG1lcy54ID0geDtcbiAgICAgIG1lcy55ID0geTtcbiAgICAgIG1lcy53aWR0aCA9IHdpZHRoO1xuICAgICAgbWVzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5wYXJlbnRHcm91cCA9IGdyb3VwO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZHJhdyAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICAgIHZhciBtZWFzdXJlbWVudCA9IHRoaXMubWVhc3VyZW1lbnQsXG4gICAgICAgIHRvb2xiYXJzID0gdGhpcy50b29sYmFycyxcbiAgICAgICAgbG4sXG4gICAgICAgIGksXG4gICAgICAgIHRvb2xiYXIsXG4gICAgICAgIG1vZGVsID0gdGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLFxuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgIGNvbnNvbGUubG9nKG1vZGVsKTtcbiAgICAgIHggPSB4ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC54IDogeDtcbiAgICAgIHkgPSB5ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC55IDogeTtcbiAgICAgIHdpZHRoID0gd2lkdGggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LndpZHRoIDogd2lkdGg7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LmhlaWdodCA6IGhlaWdodDtcbiAgICAgIGdyb3VwID0gZ3JvdXAgPT09IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50R3JvdXAgOiBncm91cDtcbiAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbG4gPSB0b29sYmFycy5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgICAgdG9vbGJhciA9IHRvb2xiYXJzW2ldO1xuICAgICAgICAgIHRvb2xiYXIuZHJhdyh4LCB5LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9kZWwub25Qcm9wc0NoYW5nZShbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLXN0YXJ0JywgJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBzZWxmLmZyb21EYXRlLmJsdXIobmV3IERhdGUoc3RhcnRbMV0pLnRvTG9jYWxlRGF0ZVN0cmluZygpKTtcbiAgICAgICAgc2VsZi50b0RhdGUuYmx1cihuZXcgRGF0ZShlbmRbMV0pLnRvTG9jYWxlRGF0ZVN0cmluZygpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIERhdGVSYW5nZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==