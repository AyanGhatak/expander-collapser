/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(2);
	
	window.dr = new DateRange();
	
	;(function (env, factory) {
	  if (typeof module === 'object' && module.exports) {
	    module.exports = env.document
	       ? factory(env) : function (win) {
	         if (!win.document) {
	           throw new Error('Window with document not present');
	         }
	         return factory(win, true);
	       };
	  } else {
	    env.DateRangeChooser = factory(env, true);
	  }
	})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {
	  var FC = _window.FusionCharts;
	  FC.register('extension', ['private', 'DateRangeChooser', function () {
	    FC.registerComponent('extensions', 'DateRangeChooser', DateRange);
	  }]);
	});


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	class DateRange {
	  constructor () {
	    /**
	     * @private
	     */
	    this.startDt = 0;
	    this.endDt = 0;
	    this.startDataset = 0;
	    this.endDataset = 0;
	    this.toolbox = FusionCharts.getComponent('api', 'toolbox');
	    this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	    this.ComponentGroup = this.toolbox.ComponentGroup;
	    this.SymbolStore = this.toolbox.SymbolStore;
	    this.startText = {
	      attr: function () {}
	    };
	    this.endText = {
	      attr: function () {}
	    };
	  }
	
	  /**
	   * An object representing the start and end dates.
	   * @type {DateRange.range}
	   */
	  get startDate () {
	    return this.startDt;
	  }
	
	  set startDate (startDt) {
	    let startTimestamp = +new Date(startDt);
	    if (startTimestamp <= this.endDt) {
	      this.startDt = startTimestamp;
	      // console.log(this.globalReactiveModel.model['x-axis-visible-range-start']);
	      this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;
	      // console.log(this.globalReactiveModel.model['x-axis-visible-range-start']);
	    }
	  }
	
	  get endDate () {
	    return this.endDt;
	  }
	
	  set endDate (endDt) {
	    let endTimestamp = +new Date(endDt);
	    console.log(endDt);
	    if (endTimestamp >= this.startDt) {
	      this.endDt = endTimestamp;
	      // console.log(this.globalReactiveModel.model['x-axis-visible-range-end']);
	      this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;
	      // console.log(this.globalReactiveModel.model['x-axis-visible-range-end']);
	    }
	  }
	
	  /**
	   * Swaps the start date and the end date of the date range
	   * @private
	   */
	  swapDates () {
	    let temp = this.dateRange.startDate;
	    this.dateRange.startDate = this.dateRange.endDate;
	    this.dateRange.endDate = temp;
	  }
	
	  /**
	   * Syncs the daterange shown by the FusionCharts time series chart and the Date Range Chooser
	   * @private
	   */
	  syncRange () {}
	
	  /**
	   * Returns a formatted date string from FusionCharts when given a UNIX timestamp
	   * @param  {number} timestamp - A UNIX timestamp to be converted to a date string
	   * @return {string} - A date string which is equivalent to the given timestamp
	   */
	  getFormattedDate (timestamp) {
	    return this.chart.getFormattedDate(timestamp);
	  }
	
	  /**
	   * Returns a UNIX timestamp from FusionCharts when given a formatted date string
	   * @param  {string} dateString - A date string to be converted to a UNIX timestamp
	   * @return {number} A UNIX timestamp which is equivalent to the given date string
	   */
	  getTimestamp (dateString) {
	    return this.chart.getTimestamp(dateString);
	  }
	
	  /**
	   * Sets the configurable options of the extension (e.g. cosmetics)
	   * @param {Object} configObj The configuration object containing various extension options
	   */
	  setConfig (configObj) {}
	
	  /**
	   * Gets the configurable options of the extension (e.g. cosmetics)
	   * @return {object} configObj The configuration object containing various extension options
	   */
	  getConfig () {
	    return {
	      calendarVisible: 'false'
	    };
	  }
	
	  /**
	   * Fusioncharts life cycle method for extension
	   */
	  init (require) {
	    var instance = this;
	    require([
	      'xAxis',
	      'yAxis',
	      'graphics',
	      'chart',
	      'dataset',
	      'PlotManager',
	      'canvasConfig',
	      'MarkerManager',
	      'reactiveModel',
	      'globalReactiveModel',
	      'spaceManagerInstance',
	      'smartLabel',
	      function (
	            xAxis,
	            yAxis,
	            graphics,
	            chart,
	            dataset,
	            plotManager,
	            canvasConfig,
	            markerManager,
	            reactiveModel,
	            globalReactiveModel,
	            spaceManagerInstance,
	            smartLabel) {
	        instance.xAxis = xAxis;
	        instance.yAxis = yAxis;
	        instance.graphics = graphics;
	        instance.chart = chart;
	        instance.dataset = dataset;
	        instance.plotManager = plotManager;
	        instance.markerManager = markerManager;
	        instance.canvasConfig = canvasConfig;
	        instance.reactiveModel = reactiveModel;
	        instance.globalReactiveModel = globalReactiveModel;
	        instance.spaceManagerInstance = spaceManagerInstance;
	        instance.smartLabel = smartLabel;
	      }
	    ]);
	    this.spaceManagerInstance = instance.spaceManagerInstance;
	    this.globalReactiveModel = instance.globalReactiveModel;
	    this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	    this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	    this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	    this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	    this.toolbars = [];
	    this.measurement = {};
	    this.toolbars.push(this.createToolbar());
	    console.log(this.createToolbar());
	    console.log(this.dateStart, this.dateEnd);
	    return this;
	  };
	
	  createToolbar () {
	    var toolbar,
	      fromDate,
	      toDate,
	      self = this,
	      fromDateLabel,
	      toDateLabel,
	      group,
	      fromFormattedDate,
	      toFormattedDate;
	
	    fromFormattedDate = (new Date(this.startDt).getUTCMonth() + 1) + '-' +
	      new Date(this.startDt).getUTCDate() + '-' + new Date(this.startDt).getUTCFullYear();
	
	    toFormattedDate = new Date(this.endDt).getUTCMonth() + '-' +
	      (new Date(this.endDt).getUTCDate() + 1) + '-' + new Date(this.endDt).getUTCFullYear();
	
	    toolbar = new this.HorizontalToolbar({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    toolbar.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    group = new this.toolbox.ComponentGroup({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    group.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    fromDateLabel = new this.toolbox.Label('From:', {
	      smartLabel: this.smartLabel,
	      paper: this.graphics.paper
	    }, {
	      text: {
	        style: {
	          'font-size': '15',
	          'fontFamily': 'MyriadPro'
	        }
	      }
	    });
	
	    fromDate = new this.toolbox.InputTextBoxSymbol({
	      width: 120,
	      height: 25
	    }, {
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    }, {
	      strokeWidth: 1,
	      stroke: 'rgba(102,102,102,0.5)',
	      symbolStrokeWidth: 0,
	      btnTextStyle: {
	        fontSize: 14
	      },
	      label: fromFormattedDate
	    });
	
	    toDateLabel = new this.toolbox.Label('To:', {
	      smartLabel: this.smartLabel,
	      paper: this.graphics.paper
	    }, {
	      text: {
	        style: {
	          'font-size': '15',
	          'fontFamily': 'MyriadPro'
	        }
	      }
	    });
	
	    toDate = new this.toolbox.InputTextBoxSymbol({
	      width: 120,
	      height: 25
	    }, {
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    }, {
	      strokeWidth: 1,
	      stroke: 'rgba(102,102,102,0.5)',
	      symbolStrokeWidth: 0,
	      btnTextStyle: {
	        fontSize: 14
	      },
	      label: toFormattedDate
	    });
	
	    fromDate.attachEventHandlers({
	      click: {
	        fn: fromDate.edit
	      },
	      textOnBlur: function () {
	        fromDate.blur();
	        self.startDate = fromDate.getText();
	        console.log(fromDate.getText());
	      }
	    });
	
	    toDate.attachEventHandlers({
	      click: {
	        fn: toDate.edit
	      },
	      textOnBlur: function () {
	        toDate.blur();
	        console.log(toDate.getText());
	        self.endDate = toDate.getText();
	      }
	    });
	
	    this.SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
	      var x1 = x - w / 2 + padX / 2,
	        x2 = x + w / 2 - padX / 2,
	        y1 = y - h / 2 + padY / 2,
	        y2 = y + h / 2 - padY / 2;
	
	      return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
	    });
	
	    group.addSymbol(fromDateLabel);
	    group.addSymbol(fromDate);
	    group.addSymbol(toDateLabel);
	    group.addSymbol(toDate);
	    toolbar.addComponent(group);
	    return toolbar;
	  };
	
	  getLogicalSpace (availableWidth, availableHeight) {
	    availableWidth /= 2;
	    var logicalSpace,
	      width = 0,
	      height = 0,
	      i,
	      ln;
	
	    for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	      logicalSpace = this.toolbars[i].getLogicalSpace();
	      width = Math.max(logicalSpace.width, width);
	      height += logicalSpace.height;
	      this.toolbars[i].width = logicalSpace.width;
	      this.toolbars[i].height = logicalSpace.height;
	    }
	    height += this.padding;
	    return {
	      width: width > availableWidth ? 0 : width,
	      height: height > availableHeight ? 0 : height
	    };
	  };
	
	  placeInCanvas () {
	    var self = this;
	    self.padding = 5;
	    self.spaceManagerInstance.add([{
	      name: function () {
	        return 'ToolBoxExt';
	      },
	      ref: function (obj) {
	        return obj['0'];
	      },
	      self: function () {
	        return self;
	      },
	      priority: function () {
	        return 2;
	      },
	      layout: function (obj) {
	        return obj.inline;
	      },
	      orientation: [{
	        type: function (obj) {
	          return obj.horizontal;
	        },
	        position: [{
	          type: function (obj) {
	            return obj.top;
	          },
	          alignment: [{
	            type: function (obj) {
	              return obj.left;
	            },
	            dimensions: [function () {
	              var parent = this.getParentComponentGroup();
	              return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	            }]
	          }]
	        }]
	      }]
	    }]);
	  };
	
	  setDrawingConfiguration (x, y, width, height, group) {
	    var mes = this.measurement;
	    mes.x = x;
	    mes.y = y;
	    mes.width = width;
	    mes.height = height;
	
	    this.parentGroup = group;
	
	    return this;
	  };
	
	  draw (x, y, width, height, group) {
	    var measurement = this.measurement,
	      toolbars = this.toolbars,
	      ln,
	      i,
	      toolbar;
	
	    x = x === undefined ? measurement.x : x;
	    y = y === undefined ? measurement.y : y;
	    width = width === undefined ? measurement.width : width;
	    height = height === undefined ? measurement.height : height;
	    group = group === undefined ? this.parentGroup : group;
	    if (width && height) {
	      for (i = 0, ln = toolbars.length; i < ln; i++) {
	        toolbar = toolbars[i];
	        toolbar.draw(x, y);
	      }
	    }
	  };
	}
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = DateRange;
	} else {
	  window.StandardPeriod = DateRange;
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODI1OWJhYjgzOTUyOGY3NTFjZWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWCxVQUFTO0FBQ1QsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiJmY3RzLWV4dC1kYXRlcmFuZ2UtZXM2Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDgyNTliYWI4Mzk1MjhmNzUxY2ViIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgRGF0ZVJhbmdlID0gcmVxdWlyZSgnLi9mY3RzLWV4dC1kYXRlcmFuZ2UnKTtcblxud2luZG93LmRyID0gbmV3IERhdGVSYW5nZSgpO1xuXG47KGZ1bmN0aW9uIChlbnYsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnYuZG9jdW1lbnRcbiAgICAgICA/IGZhY3RvcnkoZW52KSA6IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAgICAgIGlmICghd2luLmRvY3VtZW50KSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IHdpdGggZG9jdW1lbnQgbm90IHByZXNlbnQnKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWN0b3J5KHdpbiwgdHJ1ZSk7XG4gICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbnYuRGF0ZVJhbmdlQ2hvb3NlciA9IGZhY3RvcnkoZW52LCB0cnVlKTtcbiAgfVxufSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoX3dpbmRvdywgd2luZG93RXhpc3RzKSB7XG4gIHZhciBGQyA9IF93aW5kb3cuRnVzaW9uQ2hhcnRzO1xuICBGQy5yZWdpc3RlcignZXh0ZW5zaW9uJywgWydwcml2YXRlJywgJ0RhdGVSYW5nZUNob29zZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgRkMucmVnaXN0ZXJDb21wb25lbnQoJ2V4dGVuc2lvbnMnLCAnRGF0ZVJhbmdlQ2hvb3NlcicsIERhdGVSYW5nZSk7XG4gIH1dKTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIERhdGVSYW5nZS5cbiAqL1xuY2xhc3MgRGF0ZVJhbmdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdGFydER0ID0gMDtcbiAgICB0aGlzLmVuZER0ID0gMDtcbiAgICB0aGlzLnN0YXJ0RGF0YXNldCA9IDA7XG4gICAgdGhpcy5lbmREYXRhc2V0ID0gMDtcbiAgICB0aGlzLnRvb2xib3ggPSBGdXNpb25DaGFydHMuZ2V0Q29tcG9uZW50KCdhcGknLCAndG9vbGJveCcpO1xuICAgIHRoaXMuSG9yaXpvbnRhbFRvb2xiYXIgPSB0aGlzLnRvb2xib3guSG9yaXpvbnRhbFRvb2xiYXI7XG4gICAgdGhpcy5Db21wb25lbnRHcm91cCA9IHRoaXMudG9vbGJveC5Db21wb25lbnRHcm91cDtcbiAgICB0aGlzLlN5bWJvbFN0b3JlID0gdGhpcy50b29sYm94LlN5bWJvbFN0b3JlO1xuICAgIHRoaXMuc3RhcnRUZXh0ID0ge1xuICAgICAgYXR0cjogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIHRoaXMuZW5kVGV4dCA9IHtcbiAgICAgIGF0dHI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzLlxuICAgKiBAdHlwZSB7RGF0ZVJhbmdlLnJhbmdlfVxuICAgKi9cbiAgZ2V0IHN0YXJ0RGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnREdDtcbiAgfVxuXG4gIHNldCBzdGFydERhdGUgKHN0YXJ0RHQpIHtcbiAgICBsZXQgc3RhcnRUaW1lc3RhbXAgPSArbmV3IERhdGUoc3RhcnREdCk7XG4gICAgaWYgKHN0YXJ0VGltZXN0YW1wIDw9IHRoaXMuZW5kRHQpIHtcbiAgICAgIHRoaXMuc3RhcnREdCA9IHN0YXJ0VGltZXN0YW1wO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1zdGFydCddKTtcbiAgICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXSA9IHRoaXMuc3RhcnREdDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGVuZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZER0O1xuICB9XG5cbiAgc2V0IGVuZERhdGUgKGVuZER0KSB7XG4gICAgbGV0IGVuZFRpbWVzdGFtcCA9ICtuZXcgRGF0ZShlbmREdCk7XG4gICAgY29uc29sZS5sb2coZW5kRHQpO1xuICAgIGlmIChlbmRUaW1lc3RhbXAgPj0gdGhpcy5zdGFydER0KSB7XG4gICAgICB0aGlzLmVuZER0ID0gZW5kVGltZXN0YW1wO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1lbmQnXSk7XG4gICAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddID0gdGhpcy5lbmREdDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2UtZW5kJ10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwcyB0aGUgc3RhcnQgZGF0ZSBhbmQgdGhlIGVuZCBkYXRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzd2FwRGF0ZXMgKCkge1xuICAgIGxldCB0ZW1wID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlO1xuICAgIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZSA9IHRoaXMuZGF0ZVJhbmdlLmVuZERhdGU7XG4gICAgdGhpcy5kYXRlUmFuZ2UuZW5kRGF0ZSA9IHRlbXA7XG4gIH1cblxuICAvKipcbiAgICogU3luY3MgdGhlIGRhdGVyYW5nZSBzaG93biBieSB0aGUgRnVzaW9uQ2hhcnRzIHRpbWUgc2VyaWVzIGNoYXJ0IGFuZCB0aGUgRGF0ZSBSYW5nZSBDaG9vc2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzeW5jUmFuZ2UgKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBmcm9tIEZ1c2lvbkNoYXJ0cyB3aGVuIGdpdmVuIGEgVU5JWCB0aW1lc3RhbXBcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lc3RhbXAgLSBBIFVOSVggdGltZXN0YW1wIHRvIGJlIGNvbnZlcnRlZCB0byBhIGRhdGUgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gLSBBIGRhdGUgc3RyaW5nIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHRpbWVzdGFtcFxuICAgKi9cbiAgZ2V0Rm9ybWF0dGVkRGF0ZSAodGltZXN0YW1wKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0Rm9ybWF0dGVkRGF0ZSh0aW1lc3RhbXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBVTklYIHRpbWVzdGFtcCBmcm9tIEZ1c2lvbkNoYXJ0cyB3aGVuIGdpdmVuIGEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZGF0ZVN0cmluZyAtIEEgZGF0ZSBzdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIGEgVU5JWCB0aW1lc3RhbXBcbiAgICogQHJldHVybiB7bnVtYmVyfSBBIFVOSVggdGltZXN0YW1wIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGRhdGUgc3RyaW5nXG4gICAqL1xuICBnZXRUaW1lc3RhbXAgKGRhdGVTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXRUaW1lc3RhbXAoZGF0ZVN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29uZmlndXJhYmxlIG9wdGlvbnMgb2YgdGhlIGV4dGVuc2lvbiAoZS5nLiBjb3NtZXRpY3MpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdmFyaW91cyBleHRlbnNpb24gb3B0aW9uc1xuICAgKi9cbiAgc2V0Q29uZmlnIChjb25maWdPYmopIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIG9mIHRoZSBleHRlbnNpb24gKGUuZy4gY29zbWV0aWNzKVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGNvbmZpZ09iaiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyB2YXJpb3VzIGV4dGVuc2lvbiBvcHRpb25zXG4gICAqL1xuICBnZXRDb25maWcgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYWxlbmRhclZpc2libGU6ICdmYWxzZSdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1c2lvbmNoYXJ0cyBsaWZlIGN5Y2xlIG1ldGhvZCBmb3IgZXh0ZW5zaW9uXG4gICAqL1xuICBpbml0IChyZXF1aXJlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgICByZXF1aXJlKFtcbiAgICAgICd4QXhpcycsXG4gICAgICAneUF4aXMnLFxuICAgICAgJ2dyYXBoaWNzJyxcbiAgICAgICdjaGFydCcsXG4gICAgICAnZGF0YXNldCcsXG4gICAgICAnUGxvdE1hbmFnZXInLFxuICAgICAgJ2NhbnZhc0NvbmZpZycsXG4gICAgICAnTWFya2VyTWFuYWdlcicsXG4gICAgICAncmVhY3RpdmVNb2RlbCcsXG4gICAgICAnZ2xvYmFsUmVhY3RpdmVNb2RlbCcsXG4gICAgICAnc3BhY2VNYW5hZ2VySW5zdGFuY2UnLFxuICAgICAgJ3NtYXJ0TGFiZWwnLFxuICAgICAgZnVuY3Rpb24gKFxuICAgICAgICAgICAgeEF4aXMsXG4gICAgICAgICAgICB5QXhpcyxcbiAgICAgICAgICAgIGdyYXBoaWNzLFxuICAgICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgcGxvdE1hbmFnZXIsXG4gICAgICAgICAgICBjYW52YXNDb25maWcsXG4gICAgICAgICAgICBtYXJrZXJNYW5hZ2VyLFxuICAgICAgICAgICAgcmVhY3RpdmVNb2RlbCxcbiAgICAgICAgICAgIGdsb2JhbFJlYWN0aXZlTW9kZWwsXG4gICAgICAgICAgICBzcGFjZU1hbmFnZXJJbnN0YW5jZSxcbiAgICAgICAgICAgIHNtYXJ0TGFiZWwpIHtcbiAgICAgICAgaW5zdGFuY2UueEF4aXMgPSB4QXhpcztcbiAgICAgICAgaW5zdGFuY2UueUF4aXMgPSB5QXhpcztcbiAgICAgICAgaW5zdGFuY2UuZ3JhcGhpY3MgPSBncmFwaGljcztcbiAgICAgICAgaW5zdGFuY2UuY2hhcnQgPSBjaGFydDtcbiAgICAgICAgaW5zdGFuY2UuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICAgIGluc3RhbmNlLnBsb3RNYW5hZ2VyID0gcGxvdE1hbmFnZXI7XG4gICAgICAgIGluc3RhbmNlLm1hcmtlck1hbmFnZXIgPSBtYXJrZXJNYW5hZ2VyO1xuICAgICAgICBpbnN0YW5jZS5jYW52YXNDb25maWcgPSBjYW52YXNDb25maWc7XG4gICAgICAgIGluc3RhbmNlLnJlYWN0aXZlTW9kZWwgPSByZWFjdGl2ZU1vZGVsO1xuICAgICAgICBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsID0gZ2xvYmFsUmVhY3RpdmVNb2RlbDtcbiAgICAgICAgaW5zdGFuY2Uuc3BhY2VNYW5hZ2VySW5zdGFuY2UgPSBzcGFjZU1hbmFnZXJJbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2Uuc21hcnRMYWJlbCA9IHNtYXJ0TGFiZWw7XG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5zcGFjZU1hbmFnZXJJbnN0YW5jZSA9IGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlO1xuICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgdGhpcy5zdGFydER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy5zdGFydERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy50b29sYmFycyA9IFtdO1xuICAgIHRoaXMubWVhc3VyZW1lbnQgPSB7fTtcbiAgICB0aGlzLnRvb2xiYXJzLnB1c2godGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuY3JlYXRlVG9vbGJhcigpKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGVTdGFydCwgdGhpcy5kYXRlRW5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBjcmVhdGVUb29sYmFyICgpIHtcbiAgICB2YXIgdG9vbGJhcixcbiAgICAgIGZyb21EYXRlLFxuICAgICAgdG9EYXRlLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBmcm9tRGF0ZUxhYmVsLFxuICAgICAgdG9EYXRlTGFiZWwsXG4gICAgICBncm91cCxcbiAgICAgIGZyb21Gb3JtYXR0ZWREYXRlLFxuICAgICAgdG9Gb3JtYXR0ZWREYXRlO1xuXG4gICAgZnJvbUZvcm1hdHRlZERhdGUgPSAobmV3IERhdGUodGhpcy5zdGFydER0KS5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgbmV3IERhdGUodGhpcy5zdGFydER0KS5nZXRVVENEYXRlKCkgKyAnLScgKyBuZXcgRGF0ZSh0aGlzLnN0YXJ0RHQpLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICB0b0Zvcm1hdHRlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmVuZER0KS5nZXRVVENNb250aCgpICsgJy0nICtcbiAgICAgIChuZXcgRGF0ZSh0aGlzLmVuZER0KS5nZXRVVENEYXRlKCkgKyAxKSArICctJyArIG5ldyBEYXRlKHRoaXMuZW5kRHQpLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICB0b29sYmFyID0gbmV3IHRoaXMuSG9yaXpvbnRhbFRvb2xiYXIoe1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgdG9vbGJhci5zZXRDb25maWcoe1xuICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgYm9yZGVyVGhpY2tuZXNzOiAwXG4gICAgfSk7XG5cbiAgICBncm91cCA9IG5ldyB0aGlzLnRvb2xib3guQ29tcG9uZW50R3JvdXAoe1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgZ3JvdXAuc2V0Q29uZmlnKHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIGJvcmRlclRoaWNrbmVzczogMFxuICAgIH0pO1xuXG4gICAgZnJvbURhdGVMYWJlbCA9IG5ldyB0aGlzLnRvb2xib3guTGFiZWwoJ0Zyb206Jywge1xuICAgICAgc21hcnRMYWJlbDogdGhpcy5zbWFydExhYmVsLFxuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXJcbiAgICB9LCB7XG4gICAgICB0ZXh0OiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxNScsXG4gICAgICAgICAgJ2ZvbnRGYW1pbHknOiAnTXlyaWFkUHJvJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmcm9tRGF0ZSA9IG5ldyB0aGlzLnRvb2xib3guSW5wdXRUZXh0Qm94U3ltYm9sKHtcbiAgICAgIHdpZHRoOiAxMjAsXG4gICAgICBoZWlnaHQ6IDI1XG4gICAgfSwge1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0sIHtcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAwLFxuICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiBmcm9tRm9ybWF0dGVkRGF0ZVxuICAgIH0pO1xuXG4gICAgdG9EYXRlTGFiZWwgPSBuZXcgdGhpcy50b29sYm94LkxhYmVsKCdUbzonLCB7XG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBwYXBlcjogdGhpcy5ncmFwaGljcy5wYXBlclxuICAgIH0sIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAnZm9udC1zaXplJzogJzE1JyxcbiAgICAgICAgICAnZm9udEZhbWlseSc6ICdNeXJpYWRQcm8nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRvRGF0ZSA9IG5ldyB0aGlzLnRvb2xib3guSW5wdXRUZXh0Qm94U3ltYm9sKHtcbiAgICAgIHdpZHRoOiAxMjAsXG4gICAgICBoZWlnaHQ6IDI1XG4gICAgfSwge1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0sIHtcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAwLFxuICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB0b0Zvcm1hdHRlZERhdGVcbiAgICB9KTtcblxuICAgIGZyb21EYXRlLmF0dGFjaEV2ZW50SGFuZGxlcnMoe1xuICAgICAgY2xpY2s6IHtcbiAgICAgICAgZm46IGZyb21EYXRlLmVkaXRcbiAgICAgIH0sXG4gICAgICB0ZXh0T25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyb21EYXRlLmJsdXIoKTtcbiAgICAgICAgc2VsZi5zdGFydERhdGUgPSBmcm9tRGF0ZS5nZXRUZXh0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGZyb21EYXRlLmdldFRleHQoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0b0RhdGUuYXR0YWNoRXZlbnRIYW5kbGVycyh7XG4gICAgICBjbGljazoge1xuICAgICAgICBmbjogdG9EYXRlLmVkaXRcbiAgICAgIH0sXG4gICAgICB0ZXh0T25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRvRGF0ZS5ibHVyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRvRGF0ZS5nZXRUZXh0KCkpO1xuICAgICAgICBzZWxmLmVuZERhdGUgPSB0b0RhdGUuZ2V0VGV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5TeW1ib2xTdG9yZS5yZWdpc3RlcigndGV4dEJveEljb24nLCBmdW5jdGlvbiAoeCwgeSwgcmFkLCB3LCBoLCBwYWRYLCBwYWRZKSB7XG4gICAgICB2YXIgeDEgPSB4IC0gdyAvIDIgKyBwYWRYIC8gMixcbiAgICAgICAgeDIgPSB4ICsgdyAvIDIgLSBwYWRYIC8gMixcbiAgICAgICAgeTEgPSB5IC0gaCAvIDIgKyBwYWRZIC8gMixcbiAgICAgICAgeTIgPSB5ICsgaCAvIDIgLSBwYWRZIC8gMjtcblxuICAgICAgcmV0dXJuIFsnTScsIHgxLCB5MSwgJ0wnLCB4MiwgeTEsICdMJywgeDIsIHkyLCAnTCcsIHgxLCB5MiwgJ1onXTtcbiAgICB9KTtcblxuICAgIGdyb3VwLmFkZFN5bWJvbChmcm9tRGF0ZUxhYmVsKTtcbiAgICBncm91cC5hZGRTeW1ib2woZnJvbURhdGUpO1xuICAgIGdyb3VwLmFkZFN5bWJvbCh0b0RhdGVMYWJlbCk7XG4gICAgZ3JvdXAuYWRkU3ltYm9sKHRvRGF0ZSk7XG4gICAgdG9vbGJhci5hZGRDb21wb25lbnQoZ3JvdXApO1xuICAgIHJldHVybiB0b29sYmFyO1xuICB9O1xuXG4gIGdldExvZ2ljYWxTcGFjZSAoYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCkge1xuICAgIGF2YWlsYWJsZVdpZHRoIC89IDI7XG4gICAgdmFyIGxvZ2ljYWxTcGFjZSxcbiAgICAgIHdpZHRoID0gMCxcbiAgICAgIGhlaWdodCA9IDAsXG4gICAgICBpLFxuICAgICAgbG47XG5cbiAgICBmb3IgKGkgPSAwLCBsbiA9IHRoaXMudG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgbG9naWNhbFNwYWNlID0gdGhpcy50b29sYmFyc1tpXS5nZXRMb2dpY2FsU3BhY2UoKTtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgobG9naWNhbFNwYWNlLndpZHRoLCB3aWR0aCk7XG4gICAgICBoZWlnaHQgKz0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICAgIHRoaXMudG9vbGJhcnNbaV0ud2lkdGggPSBsb2dpY2FsU3BhY2Uud2lkdGg7XG4gICAgICB0aGlzLnRvb2xiYXJzW2ldLmhlaWdodCA9IGxvZ2ljYWxTcGFjZS5oZWlnaHQ7XG4gICAgfVxuICAgIGhlaWdodCArPSB0aGlzLnBhZGRpbmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCA+IGF2YWlsYWJsZVdpZHRoID8gMCA6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgPiBhdmFpbGFibGVIZWlnaHQgPyAwIDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICBwbGFjZUluQ2FudmFzICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wYWRkaW5nID0gNTtcbiAgICBzZWxmLnNwYWNlTWFuYWdlckluc3RhbmNlLmFkZChbe1xuICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Rvb2xCb3hFeHQnO1xuICAgICAgfSxcbiAgICAgIHJlZjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqWycwJ107XG4gICAgICB9LFxuICAgICAgc2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG4gICAgICBwcmlvcml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0sXG4gICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmxpbmU7XG4gICAgICB9LFxuICAgICAgb3JpZW50YXRpb246IFt7XG4gICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBbe1xuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9wO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLmxlZnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGltZW5zaW9uczogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q29tcG9uZW50R3JvdXAoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TG9naWNhbFNwYWNlKHBhcmVudC5nZXRXaWR0aCgpLCBwYXJlbnQuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9XSk7XG4gIH07XG5cbiAgc2V0RHJhd2luZ0NvbmZpZ3VyYXRpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdyb3VwKSB7XG4gICAgdmFyIG1lcyA9IHRoaXMubWVhc3VyZW1lbnQ7XG4gICAgbWVzLnggPSB4O1xuICAgIG1lcy55ID0geTtcbiAgICBtZXMud2lkdGggPSB3aWR0aDtcbiAgICBtZXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5wYXJlbnRHcm91cCA9IGdyb3VwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZHJhdyAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSB0aGlzLm1lYXN1cmVtZW50LFxuICAgICAgdG9vbGJhcnMgPSB0aGlzLnRvb2xiYXJzLFxuICAgICAgbG4sXG4gICAgICBpLFxuICAgICAgdG9vbGJhcjtcblxuICAgIHggPSB4ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC54IDogeDtcbiAgICB5ID0geSA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQueSA6IHk7XG4gICAgd2lkdGggPSB3aWR0aCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQud2lkdGggOiB3aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LmhlaWdodCA6IGhlaWdodDtcbiAgICBncm91cCA9IGdyb3VwID09PSB1bmRlZmluZWQgPyB0aGlzLnBhcmVudEdyb3VwIDogZ3JvdXA7XG4gICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgZm9yIChpID0gMCwgbG4gPSB0b29sYmFycy5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIHRvb2xiYXIgPSB0b29sYmFyc1tpXTtcbiAgICAgICAgdG9vbGJhci5kcmF3KHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBEYXRlUmFuZ2U7XG59IGVsc2Uge1xuICB3aW5kb3cuU3RhbmRhcmRQZXJpb2QgPSBEYXRlUmFuZ2U7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==