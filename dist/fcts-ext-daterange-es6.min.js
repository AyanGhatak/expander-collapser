/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const DateRange = __webpack_require__(2);
	
	window.dr = new DateRange();
	
	;(function (env, factory) {
	  if (typeof module === 'object' && module.exports) {
	    module.exports = env.document
	       ? factory(env) : function (win) {
	         if (!win.document) {
	           throw new Error('Window with document not present');
	         }
	         return factory(win, true);
	       };
	  } else {
	    env.DateRangeChooser = factory(env, true);
	  }
	})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {
	  var FC = _window.FusionCharts;
	  FC.register('extension', ['private', 'DateRangeChooser', function () {
	    FC.registerComponent('extensions', 'DateRangeChooser', DateRange({FusionCharts: FC}));
	  }]);
	});


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Class representing the DateRange.
	 */
	
	module.exports = function (dep) {
	  class DateRange {
	    constructor () {
	      /**
	       * @private
	       */
	
	      this.startDt = 0;
	      this.endDt = 0;
	      this.startDataset = 0;
	      this.endDataset = 0;
	      this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');
	      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	      this.ComponentGroup = this.toolbox.ComponentGroup;
	      this.SymbolStore = this.toolbox.SymbolStore;
	      this.startText = {
	        attr: function () {}
	      };
	      this.endText = {
	        attr: function () {}
	      };
	    }
	
	    /**
	     * An object representing the start and end dates.
	     * @type {DateRange.range}
	     */
	    get startDate () {
	      return this.startDt;
	    }
	
	    set startDate (startDt) {
	      let startTimestamp = +new Date(startDt);
	      if (startTimestamp <= this.endDt) {
	        this.startDt = startTimestamp;
	        this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;
	      }
	    }
	
	    get endDate () {
	      return this.endDt;
	    }
	
	    set endDate (endDt) {
	      let endTimestamp = +new Date(endDt);
	      if (endTimestamp >= this.startDt) {
	        this.endDt = endTimestamp;
	        this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;
	      }
	    }
	
	    /**
	     * Swaps the start date and the end date of the date range
	     * @private
	     */
	    swapDates () {
	      let temp = this.dateRange.startDate;
	      this.dateRange.startDate = this.dateRange.endDate;
	      this.dateRange.endDate = temp;
	    }
	
	    /**
	     * Syncs the daterange shown by the FusionCharts time series chart and the Date Range Chooser
	     * @private
	     */
	    syncRange () {}
	
	    /**
	     * Returns a formatted date string from FusionCharts when given a UNIX timestamp
	     * @param  {number} timestamp - A UNIX timestamp to be converted to a date string
	     * @return {string} - A date string which is equivalent to the given timestamp
	     */
	    getFormattedDate (timestamp) {
	      return this.chart.getFormattedDate(timestamp);
	    }
	
	    /**
	     * Returns a UNIX timestamp from FusionCharts when given a formatted date string
	     * @param  {string} dateString - A date string to be converted to a UNIX timestamp
	     * @return {number} A UNIX timestamp which is equivalent to the given date string
	     */
	    getTimestamp (dateString) {
	      return this.chart.getTimestamp(dateString);
	    }
	
	    /**
	     * Sets the configurable options of the extension (e.g. cosmetics)
	     * @param {Object} configObj The configuration object containing various extension options
	     */
	    setConfig (configObj) {}
	
	    /**
	     * Gets the configurable options of the extension (e.g. cosmetics)
	     * @return {object} configObj The configuration object containing various extension options
	     */
	    getConfig () {
	      return {
	        calendarVisible: 'false'
	      };
	    }
	
	    /**
	     * Fusioncharts life cycle method for extension
	     */
	    init (require) {
	      var instance = this;
	      require([
	        'xAxis',
	        'yAxis',
	        'graphics',
	        'chart',
	        'dataset',
	        'PlotManager',
	        'canvasConfig',
	        'MarkerManager',
	        'reactiveModel',
	        'globalReactiveModel',
	        'spaceManagerInstance',
	        'smartLabel',
	        'chartInstance',
	        function (
	              xAxis,
	              yAxis,
	              graphics,
	              chart,
	              dataset,
	              plotManager,
	              canvasConfig,
	              markerManager,
	              reactiveModel,
	              globalReactiveModel,
	              spaceManagerInstance,
	              smartLabel) {
	          instance.xAxis = xAxis;
	          instance.yAxis = yAxis;
	          instance.graphics = graphics;
	          instance.chart = chart;
	          instance.dataset = dataset;
	          instance.plotManager = plotManager;
	          instance.markerManager = markerManager;
	          instance.canvasConfig = canvasConfig;
	          instance.reactiveModel = reactiveModel;
	          instance.globalReactiveModel = globalReactiveModel;
	          instance.spaceManagerInstance = spaceManagerInstance;
	          instance.smartLabel = smartLabel;
	        }
	      ]);
	      this.spaceManagerInstance = instance.spaceManagerInstance;
	      this.globalReactiveModel = instance.globalReactiveModel;
	      this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	      this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	      this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	      this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	      this.toolbars = [];
	      this.measurement = {};
	      this.toolbars.push(this.createToolbar());
	      return this;
	    };
	
	    createToolbar () {
	      var toolbar,
	        self = this,
	        fromDateLabel,
	        toDateLabel,
	        group,
	        fromFormattedDate,
	        toFormattedDate;
	
	      self.fromDate = {};
	      self.toDate = {};
	
	      fromFormattedDate = new Date(this.startDt).toLocaleDateString();
	
	      toFormattedDate = new Date(this.endDt).toLocaleDateString();
	
	      toolbar = new this.HorizontalToolbar({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      toolbar.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      group = new this.toolbox.ComponentGroup({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      group.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      fromDateLabel = new this.toolbox.Label('From:', {
	        smartLabel: this.smartLabel,
	        paper: this.graphics.paper
	      }, {
	        text: {
	          style: {
	            'font-size': '15',
	            'font-family': 'MyriadPro'
	          }
	        }
	      });
	
	      self.fromDate = new this.toolbox.InputTextBoxSymbol({
	        width: 80,
	        height: 22
	      }, {
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        margin: {
	          right: 22
	        },
	        btnTextStyle: {
	          fontSize: 14
	        },
	        label: fromFormattedDate
	      });
	
	      toDateLabel = new this.toolbox.Label('To:', {
	        smartLabel: this.smartLabel,
	        paper: this.graphics.paper
	      }, {
	        text: {
	          style: {
	            'font-size': '15',
	            'font-family': 'MyriadPro'
	          }
	        }
	      });
	
	      self.toDate = new this.toolbox.InputTextBoxSymbol({
	        width: 80,
	        height: 22
	      }, {
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        btnTextStyle: {
	          fontSize: 14
	        },
	        label: toFormattedDate
	      });
	
	      self.fromDate.attachEventHandlers({
	        click: {
	          fn: self.fromDate.edit
	        },
	        textOnBlur: function () {
	          self.fromDate.blur();
	          self.startDate = self.fromDate.getText();
	        }
	      });
	
	      self.toDate.attachEventHandlers({
	        click: {
	          fn: self.toDate.edit
	        },
	        textOnBlur: function () {
	          self.toDate.blur();
	          self.endDate = self.toDate.getText();
	        }
	      });
	
	      this.SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
	        var x1 = x - w / 2 + padX / 2,
	          x2 = x + w / 2 - padX / 2,
	          y1 = y - h / 2 + padY / 2,
	          y2 = y + h / 2 - padY / 2;
	
	        return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
	      });
	
	      group.addSymbol(fromDateLabel);
	      group.addSymbol(self.fromDate);
	      group.addSymbol(toDateLabel);
	      group.addSymbol(self.toDate);
	      toolbar.addComponent(group);
	      return toolbar;
	    };
	
	    getLogicalSpace (availableWidth, availableHeight) {
	      availableWidth /= 2;
	      var logicalSpace,
	        width = 0,
	        height = 0,
	        i,
	        ln;
	
	      for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	        logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
	        width = Math.max(logicalSpace.width, width);
	        height += logicalSpace.height;
	        this.toolbars[i].width = logicalSpace.width;
	        this.toolbars[i].height = logicalSpace.height;
	      }
	      height += this.padding;
	      return {
	        width: width,
	        height: height
	      };
	    };
	
	    placeInCanvas () {
	      var self = this;
	      self.padding = 5;
	      self.spaceManagerInstance.add([{
	        name: function () {
	          return 'ToolBoxExt';
	        },
	        ref: function (obj) {
	          return obj['0'];
	        },
	        self: function () {
	          return self;
	        },
	        priority: function () {
	          return 2;
	        },
	        layout: function (obj) {
	          return obj.inline;
	        },
	        orientation: [{
	          type: function (obj) {
	            return obj.horizontal;
	          },
	          position: [{
	            type: function (obj) {
	              return obj.top;
	            },
	            alignment: [{
	              type: function (obj) {
	                return obj.right;
	              },
	              dimensions: [function () {
	                var parent = this.getParentComponentGroup();
	                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	              }]
	            }]
	          }]
	        }]
	      }]);
	    };
	
	    setDrawingConfiguration (x, y, width, height, group) {
	      var mes = this.measurement;
	      mes.x = x;
	      mes.y = y;
	      mes.width = width;
	      mes.height = height;
	
	      this.parentGroup = group;
	
	      return this;
	    };
	
	    draw (x, y, width, height, group) {
	      var measurement = this.measurement,
	        toolbars = this.toolbars,
	        ln,
	        i,
	        toolbar,
	        model = this.globalReactiveModel,
	        self = this;
	      x = x === undefined ? measurement.x : x;
	      y = y === undefined ? measurement.y : y;
	      width = width === undefined ? measurement.width : width;
	      height = height === undefined ? measurement.height : height;
	      group = group === undefined ? this.parentGroup : group;
	      if (width && height) {
	        for (i = 0, ln = toolbars.length; i < ln; i++) {
	          toolbar = toolbars[i];
	          toolbar.draw(x, y, group);
	        }
	      }
	
	      model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'], function (start, end) {
	        self.fromDate.blur(new Date(start[1]).toLocaleDateString());
	        self.toDate.blur(new Date(end[1]).toLocaleDateString());
	      });
	    };
	  }
	  return DateRange;
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2JiZjI2MWMxNWRjZDc4YzhlZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsdUVBQXNFLGlCQUFpQjtBQUN2RixJQUFHO0FBQ0gsRUFBQzs7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmLGNBQWE7QUFDYixZQUFXO0FBQ1gsVUFBUztBQUNULFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImZjdHMtZXh0LWRhdGVyYW5nZS1lczYubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgN2JiZjI2MWMxNWRjZDc4YzhlZDYiLCIndXNlIHN0cmljdCc7XG5jb25zdCBEYXRlUmFuZ2UgPSByZXF1aXJlKCcuL2ZjdHMtZXh0LWRhdGVyYW5nZScpO1xuXG53aW5kb3cuZHIgPSBuZXcgRGF0ZVJhbmdlKCk7XG5cbjsoZnVuY3Rpb24gKGVudiwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudi5kb2N1bWVudFxuICAgICAgID8gZmFjdG9yeShlbnYpIDogZnVuY3Rpb24gKHdpbikge1xuICAgICAgICAgaWYgKCF3aW4uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgd2l0aCBkb2N1bWVudCBub3QgcHJlc2VudCcpO1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZhY3Rvcnkod2luLCB0cnVlKTtcbiAgICAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVudi5EYXRlUmFuZ2VDaG9vc2VyID0gZmFjdG9yeShlbnYsIHRydWUpO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uIChfd2luZG93LCB3aW5kb3dFeGlzdHMpIHtcbiAgdmFyIEZDID0gX3dpbmRvdy5GdXNpb25DaGFydHM7XG4gIEZDLnJlZ2lzdGVyKCdleHRlbnNpb24nLCBbJ3ByaXZhdGUnLCAnRGF0ZVJhbmdlQ2hvb3NlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBGQy5yZWdpc3RlckNvbXBvbmVudCgnZXh0ZW5zaW9ucycsICdEYXRlUmFuZ2VDaG9vc2VyJywgRGF0ZVJhbmdlKHtGdXNpb25DaGFydHM6IEZDfSkpO1xuICB9XSk7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBEYXRlUmFuZ2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIGNsYXNzIERhdGVSYW5nZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuc3RhcnREdCA9IDA7XG4gICAgICB0aGlzLmVuZER0ID0gMDtcbiAgICAgIHRoaXMuc3RhcnREYXRhc2V0ID0gMDtcbiAgICAgIHRoaXMuZW5kRGF0YXNldCA9IDA7XG4gICAgICB0aGlzLnRvb2xib3ggPSBkZXAuRnVzaW9uQ2hhcnRzLmdldENvbXBvbmVudCgnYXBpJywgJ3Rvb2xib3gnKTtcbiAgICAgIHRoaXMuSG9yaXpvbnRhbFRvb2xiYXIgPSB0aGlzLnRvb2xib3guSG9yaXpvbnRhbFRvb2xiYXI7XG4gICAgICB0aGlzLkNvbXBvbmVudEdyb3VwID0gdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwO1xuICAgICAgdGhpcy5TeW1ib2xTdG9yZSA9IHRoaXMudG9vbGJveC5TeW1ib2xTdG9yZTtcbiAgICAgIHRoaXMuc3RhcnRUZXh0ID0ge1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcbiAgICAgIHRoaXMuZW5kVGV4dCA9IHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcy5cbiAgICAgKiBAdHlwZSB7RGF0ZVJhbmdlLnJhbmdlfVxuICAgICAqL1xuICAgIGdldCBzdGFydERhdGUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnREdDtcbiAgICB9XG5cbiAgICBzZXQgc3RhcnREYXRlIChzdGFydER0KSB7XG4gICAgICBsZXQgc3RhcnRUaW1lc3RhbXAgPSArbmV3IERhdGUoc3RhcnREdCk7XG4gICAgICBpZiAoc3RhcnRUaW1lc3RhbXAgPD0gdGhpcy5lbmREdCkge1xuICAgICAgICB0aGlzLnN0YXJ0RHQgPSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1zdGFydCddID0gdGhpcy5zdGFydER0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBlbmREYXRlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZER0O1xuICAgIH1cblxuICAgIHNldCBlbmREYXRlIChlbmREdCkge1xuICAgICAgbGV0IGVuZFRpbWVzdGFtcCA9ICtuZXcgRGF0ZShlbmREdCk7XG4gICAgICBpZiAoZW5kVGltZXN0YW1wID49IHRoaXMuc3RhcnREdCkge1xuICAgICAgICB0aGlzLmVuZER0ID0gZW5kVGltZXN0YW1wO1xuICAgICAgICB0aGlzLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddID0gdGhpcy5lbmREdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0aGUgc3RhcnQgZGF0ZSBhbmQgdGhlIGVuZCBkYXRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzd2FwRGF0ZXMgKCkge1xuICAgICAgbGV0IHRlbXAgPSB0aGlzLmRhdGVSYW5nZS5zdGFydERhdGU7XG4gICAgICB0aGlzLmRhdGVSYW5nZS5zdGFydERhdGUgPSB0aGlzLmRhdGVSYW5nZS5lbmREYXRlO1xuICAgICAgdGhpcy5kYXRlUmFuZ2UuZW5kRGF0ZSA9IHRlbXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3luY3MgdGhlIGRhdGVyYW5nZSBzaG93biBieSB0aGUgRnVzaW9uQ2hhcnRzIHRpbWUgc2VyaWVzIGNoYXJ0IGFuZCB0aGUgRGF0ZSBSYW5nZSBDaG9vc2VyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzeW5jUmFuZ2UgKCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgZnJvbSBGdXNpb25DaGFydHMgd2hlbiBnaXZlbiBhIFVOSVggdGltZXN0YW1wXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lc3RhbXAgLSBBIFVOSVggdGltZXN0YW1wIHRvIGJlIGNvbnZlcnRlZCB0byBhIGRhdGUgc3RyaW5nXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAtIEEgZGF0ZSBzdHJpbmcgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gdGltZXN0YW1wXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkRGF0ZSAodGltZXN0YW1wKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFydC5nZXRGb3JtYXR0ZWREYXRlKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFVOSVggdGltZXN0YW1wIGZyb20gRnVzaW9uQ2hhcnRzIHdoZW4gZ2l2ZW4gYSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGRhdGVTdHJpbmcgLSBBIGRhdGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byBhIFVOSVggdGltZXN0YW1wXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBIFVOSVggdGltZXN0YW1wIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGRhdGUgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0VGltZXN0YW1wIChkYXRlU3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFydC5nZXRUaW1lc3RhbXAoZGF0ZVN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29uZmlndXJhYmxlIG9wdGlvbnMgb2YgdGhlIGV4dGVuc2lvbiAoZS5nLiBjb3NtZXRpY3MpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ09iaiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyB2YXJpb3VzIGV4dGVuc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgc2V0Q29uZmlnIChjb25maWdPYmopIHt9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb25maWd1cmFibGUgb3B0aW9ucyBvZiB0aGUgZXh0ZW5zaW9uIChlLmcuIGNvc21ldGljcylcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGNvbmZpZ09iaiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyB2YXJpb3VzIGV4dGVuc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZ2V0Q29uZmlnICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGVuZGFyVmlzaWJsZTogJ2ZhbHNlJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdXNpb25jaGFydHMgbGlmZSBjeWNsZSBtZXRob2QgZm9yIGV4dGVuc2lvblxuICAgICAqL1xuICAgIGluaXQgKHJlcXVpcmUpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG4gICAgICByZXF1aXJlKFtcbiAgICAgICAgJ3hBeGlzJyxcbiAgICAgICAgJ3lBeGlzJyxcbiAgICAgICAgJ2dyYXBoaWNzJyxcbiAgICAgICAgJ2NoYXJ0JyxcbiAgICAgICAgJ2RhdGFzZXQnLFxuICAgICAgICAnUGxvdE1hbmFnZXInLFxuICAgICAgICAnY2FudmFzQ29uZmlnJyxcbiAgICAgICAgJ01hcmtlck1hbmFnZXInLFxuICAgICAgICAncmVhY3RpdmVNb2RlbCcsXG4gICAgICAgICdnbG9iYWxSZWFjdGl2ZU1vZGVsJyxcbiAgICAgICAgJ3NwYWNlTWFuYWdlckluc3RhbmNlJyxcbiAgICAgICAgJ3NtYXJ0TGFiZWwnLFxuICAgICAgICAnY2hhcnRJbnN0YW5jZScsXG4gICAgICAgIGZ1bmN0aW9uIChcbiAgICAgICAgICAgICAgeEF4aXMsXG4gICAgICAgICAgICAgIHlBeGlzLFxuICAgICAgICAgICAgICBncmFwaGljcyxcbiAgICAgICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICAgIHBsb3RNYW5hZ2VyLFxuICAgICAgICAgICAgICBjYW52YXNDb25maWcsXG4gICAgICAgICAgICAgIG1hcmtlck1hbmFnZXIsXG4gICAgICAgICAgICAgIHJlYWN0aXZlTW9kZWwsXG4gICAgICAgICAgICAgIGdsb2JhbFJlYWN0aXZlTW9kZWwsXG4gICAgICAgICAgICAgIHNwYWNlTWFuYWdlckluc3RhbmNlLFxuICAgICAgICAgICAgICBzbWFydExhYmVsKSB7XG4gICAgICAgICAgaW5zdGFuY2UueEF4aXMgPSB4QXhpcztcbiAgICAgICAgICBpbnN0YW5jZS55QXhpcyA9IHlBeGlzO1xuICAgICAgICAgIGluc3RhbmNlLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICAgICAgaW5zdGFuY2UuY2hhcnQgPSBjaGFydDtcbiAgICAgICAgICBpbnN0YW5jZS5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgICAgICBpbnN0YW5jZS5wbG90TWFuYWdlciA9IHBsb3RNYW5hZ2VyO1xuICAgICAgICAgIGluc3RhbmNlLm1hcmtlck1hbmFnZXIgPSBtYXJrZXJNYW5hZ2VyO1xuICAgICAgICAgIGluc3RhbmNlLmNhbnZhc0NvbmZpZyA9IGNhbnZhc0NvbmZpZztcbiAgICAgICAgICBpbnN0YW5jZS5yZWFjdGl2ZU1vZGVsID0gcmVhY3RpdmVNb2RlbDtcbiAgICAgICAgICBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsID0gZ2xvYmFsUmVhY3RpdmVNb2RlbDtcbiAgICAgICAgICBpbnN0YW5jZS5zcGFjZU1hbmFnZXJJbnN0YW5jZSA9IHNwYWNlTWFuYWdlckluc3RhbmNlO1xuICAgICAgICAgIGluc3RhbmNlLnNtYXJ0TGFiZWwgPSBzbWFydExhYmVsO1xuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAgIHRoaXMuc3BhY2VNYW5hZ2VySW5zdGFuY2UgPSBpbnN0YW5jZS5zcGFjZU1hbmFnZXJJbnN0YW5jZTtcbiAgICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgICB0aGlzLnN0YXJ0RHQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1zdGFydCddO1xuICAgICAgdGhpcy5lbmREdCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddO1xuICAgICAgdGhpcy5zdGFydERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2Utc3RhcnQnXTtcbiAgICAgIHRoaXMuZW5kRGF0YXNldCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWwubW9kZWxbJ3gtYXhpcy1hYnNvbHV0ZS1yYW5nZS1lbmQnXTtcbiAgICAgIHRoaXMudG9vbGJhcnMgPSBbXTtcbiAgICAgIHRoaXMubWVhc3VyZW1lbnQgPSB7fTtcbiAgICAgIHRoaXMudG9vbGJhcnMucHVzaCh0aGlzLmNyZWF0ZVRvb2xiYXIoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY3JlYXRlVG9vbGJhciAoKSB7XG4gICAgICB2YXIgdG9vbGJhcixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGZyb21EYXRlTGFiZWwsXG4gICAgICAgIHRvRGF0ZUxhYmVsLFxuICAgICAgICBncm91cCxcbiAgICAgICAgZnJvbUZvcm1hdHRlZERhdGUsXG4gICAgICAgIHRvRm9ybWF0dGVkRGF0ZTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZSA9IHt9O1xuICAgICAgc2VsZi50b0RhdGUgPSB7fTtcblxuICAgICAgZnJvbUZvcm1hdHRlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLnN0YXJ0RHQpLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuXG4gICAgICB0b0Zvcm1hdHRlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmVuZER0KS50b0xvY2FsZURhdGVTdHJpbmcoKTtcblxuICAgICAgdG9vbGJhciA9IG5ldyB0aGlzLkhvcml6b250YWxUb29sYmFyKHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICAgIH0pO1xuXG4gICAgICBncm91cCA9IG5ldyB0aGlzLnRvb2xib3guQ29tcG9uZW50R3JvdXAoe1xuICAgICAgICBwYXBlcjogdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgICAgY2hhcnRDb250YWluZXI6IHRoaXMuZ3JhcGhpY3MuY29udGFpbmVyXG4gICAgICB9KTtcblxuICAgICAgZ3JvdXAuc2V0Q29uZmlnKHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICAgIH0pO1xuXG4gICAgICBmcm9tRGF0ZUxhYmVsID0gbmV3IHRoaXMudG9vbGJveC5MYWJlbCgnRnJvbTonLCB7XG4gICAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXJcbiAgICAgIH0sIHtcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzE1JyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdNeXJpYWRQcm8nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZSA9IG5ldyB0aGlzLnRvb2xib3guSW5wdXRUZXh0Qm94U3ltYm9sKHtcbiAgICAgICAgd2lkdGg6IDgwLFxuICAgICAgICBoZWlnaHQ6IDIyXG4gICAgICB9LCB7XG4gICAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgICAgc21hcnRMYWJlbDogdGhpcy5zbWFydExhYmVsLFxuICAgICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICAgIH0sIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJ3JnYmEoMTAyLDEwMiwxMDIsMC41KScsXG4gICAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICByaWdodDogMjJcbiAgICAgICAgfSxcbiAgICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiBmcm9tRm9ybWF0dGVkRGF0ZVxuICAgICAgfSk7XG5cbiAgICAgIHRvRGF0ZUxhYmVsID0gbmV3IHRoaXMudG9vbGJveC5MYWJlbCgnVG86Jywge1xuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyXG4gICAgICB9LCB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxNScsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnTXlyaWFkUHJvJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYudG9EYXRlID0gbmV3IHRoaXMudG9vbGJveC5JbnB1dFRleHRCb3hTeW1ib2woe1xuICAgICAgICB3aWR0aDogODAsXG4gICAgICAgIGhlaWdodDogMjJcbiAgICAgIH0sIHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIGJ0blRleHRTdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogdG9Gb3JtYXR0ZWREYXRlXG4gICAgICB9KTtcblxuICAgICAgc2VsZi5mcm9tRGF0ZS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICBmbjogc2VsZi5mcm9tRGF0ZS5lZGl0XG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLmZyb21EYXRlLmJsdXIoKTtcbiAgICAgICAgICBzZWxmLnN0YXJ0RGF0ZSA9IHNlbGYuZnJvbURhdGUuZ2V0VGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2VsZi50b0RhdGUuYXR0YWNoRXZlbnRIYW5kbGVycyh7XG4gICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgZm46IHNlbGYudG9EYXRlLmVkaXRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dE9uQmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudG9EYXRlLmJsdXIoKTtcbiAgICAgICAgICBzZWxmLmVuZERhdGUgPSBzZWxmLnRvRGF0ZS5nZXRUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLlN5bWJvbFN0b3JlLnJlZ2lzdGVyKCd0ZXh0Qm94SWNvbicsIGZ1bmN0aW9uICh4LCB5LCByYWQsIHcsIGgsIHBhZFgsIHBhZFkpIHtcbiAgICAgICAgdmFyIHgxID0geCAtIHcgLyAyICsgcGFkWCAvIDIsXG4gICAgICAgICAgeDIgPSB4ICsgdyAvIDIgLSBwYWRYIC8gMixcbiAgICAgICAgICB5MSA9IHkgLSBoIC8gMiArIHBhZFkgLyAyLFxuICAgICAgICAgIHkyID0geSArIGggLyAyIC0gcGFkWSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIFsnTScsIHgxLCB5MSwgJ0wnLCB4MiwgeTEsICdMJywgeDIsIHkyLCAnTCcsIHgxLCB5MiwgJ1onXTtcbiAgICAgIH0pO1xuXG4gICAgICBncm91cC5hZGRTeW1ib2woZnJvbURhdGVMYWJlbCk7XG4gICAgICBncm91cC5hZGRTeW1ib2woc2VsZi5mcm9tRGF0ZSk7XG4gICAgICBncm91cC5hZGRTeW1ib2wodG9EYXRlTGFiZWwpO1xuICAgICAgZ3JvdXAuYWRkU3ltYm9sKHNlbGYudG9EYXRlKTtcbiAgICAgIHRvb2xiYXIuYWRkQ29tcG9uZW50KGdyb3VwKTtcbiAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH07XG5cbiAgICBnZXRMb2dpY2FsU3BhY2UgKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgIGF2YWlsYWJsZVdpZHRoIC89IDI7XG4gICAgICB2YXIgbG9naWNhbFNwYWNlLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGxuO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsbiA9IHRoaXMudG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICBsb2dpY2FsU3BhY2UgPSB0aGlzLnRvb2xiYXJzW2ldLmdldExvZ2ljYWxTcGFjZShhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heChsb2dpY2FsU3BhY2Uud2lkdGgsIHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ICs9IGxvZ2ljYWxTcGFjZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMudG9vbGJhcnNbaV0ud2lkdGggPSBsb2dpY2FsU3BhY2Uud2lkdGg7XG4gICAgICAgIHRoaXMudG9vbGJhcnNbaV0uaGVpZ2h0ID0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGhlaWdodCArPSB0aGlzLnBhZGRpbmc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBwbGFjZUluQ2FudmFzICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYucGFkZGluZyA9IDU7XG4gICAgICBzZWxmLnNwYWNlTWFuYWdlckluc3RhbmNlLmFkZChbe1xuICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICdUb29sQm94RXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialsnMCddO1xuICAgICAgICB9LFxuICAgICAgICBzZWxmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouaW5saW5lO1xuICAgICAgICB9LFxuICAgICAgICBvcmllbnRhdGlvbjogW3tcbiAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogW3tcbiAgICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai50b3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5yaWdodDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGltZW5zaW9uczogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDb21wb25lbnRHcm91cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldExvZ2ljYWxTcGFjZShwYXJlbnQuZ2V0V2lkdGgoKSwgcGFyZW50LmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH1dKTtcbiAgICB9O1xuXG4gICAgc2V0RHJhd2luZ0NvbmZpZ3VyYXRpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdyb3VwKSB7XG4gICAgICB2YXIgbWVzID0gdGhpcy5tZWFzdXJlbWVudDtcbiAgICAgIG1lcy54ID0geDtcbiAgICAgIG1lcy55ID0geTtcbiAgICAgIG1lcy53aWR0aCA9IHdpZHRoO1xuICAgICAgbWVzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5wYXJlbnRHcm91cCA9IGdyb3VwO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZHJhdyAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICAgIHZhciBtZWFzdXJlbWVudCA9IHRoaXMubWVhc3VyZW1lbnQsXG4gICAgICAgIHRvb2xiYXJzID0gdGhpcy50b29sYmFycyxcbiAgICAgICAgbG4sXG4gICAgICAgIGksXG4gICAgICAgIHRvb2xiYXIsXG4gICAgICAgIG1vZGVsID0gdGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsLFxuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgIHggPSB4ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC54IDogeDtcbiAgICAgIHkgPSB5ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC55IDogeTtcbiAgICAgIHdpZHRoID0gd2lkdGggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LndpZHRoIDogd2lkdGg7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LmhlaWdodCA6IGhlaWdodDtcbiAgICAgIGdyb3VwID0gZ3JvdXAgPT09IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50R3JvdXAgOiBncm91cDtcbiAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbG4gPSB0b29sYmFycy5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgICAgdG9vbGJhciA9IHRvb2xiYXJzW2ldO1xuICAgICAgICAgIHRvb2xiYXIuZHJhdyh4LCB5LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9kZWwub25Qcm9wc0NoYW5nZShbJ3gtYXhpcy12aXNpYmxlLXJhbmdlLXN0YXJ0JywgJ3gtYXhpcy12aXNpYmxlLXJhbmdlLWVuZCddLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBzZWxmLmZyb21EYXRlLmJsdXIobmV3IERhdGUoc3RhcnRbMV0pLnRvTG9jYWxlRGF0ZVN0cmluZygpKTtcbiAgICAgICAgc2VsZi50b0RhdGUuYmx1cihuZXcgRGF0ZShlbmRbMV0pLnRvTG9jYWxlRGF0ZVN0cmluZygpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIERhdGVSYW5nZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9mY3RzLWV4dC1kYXRlcmFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==