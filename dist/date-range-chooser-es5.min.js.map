{"version":3,"sources":["webpack:///date-range-chooser-es5.min.js","webpack:///webpack/bootstrap d8569594dd1e378a0549","webpack:///./src/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/fcts-ext-daterange.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_typeof","Symbol","iterator","obj","constructor","prototype","DateRange","env","factory","document","win","Error","DateRangeChooser","window","undefined","_window","windowExists","FC","FusionCharts","register","DateTimeFormatter","this","hcLib","registerComponent","webpackPolyfill","deprecate","paths","children","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","dep","startDt","endDt","startDataset","endDataset","toolbox","getComponent","HorizontalToolbar","ComponentGroup","isDrawn","startTooltipErrorMsg","endTooltipErrorMsg","createObjectAssign","value","startTimestamp","endTimestamp","errorType","config","styles","setErrorMsg","fromError","toError","timestamp","absoluteStart","absoluteEnd","actualDiff","minDiff","dateStr","dateFormat","dateFormatter","getNativeDate","formatAs","configObj","calendarVisible","extData","defaultStyles","inputButton","width","height","radius","padding","left","right","className","container","style","fill","stroke-width","stroke","text","font-family","font-size","states","selected","errored","label","disabled","layout","orientation","position","alignment","fromText","fromTooltipText","toText","toTooltipText","assign","symbol","errorGroup","errorMsg","varArgs","to","index","arguments","nextSource","nextKey","hasOwnProperty","require","xAxis","graphics","chart","dataset","globalReactiveModel","spaceManagerInstance","smartLabel","chartInstance","createConfig","model","toolbars","measurement","push","createToolbar","toolbar","fromGroup","toGroup","fromFormattedDate","toFormattedDate","labelList","inputButtonlist","self","inputBtnStyles","paper","addCssRules","classNames","cssAddRule","color","createInputButtons","store","state","d3","setConfig","namespace","appendSelector","getIndividualClassNames","getClassName","attachEventHandlers","eventListeners","group","addSymbol","createLabels","Label","dependencies","chartContainer","fromDateEventConfig","click","fromDate","setState","keypress","e","event","charCode","which","keyCode","startDate","blur","removeState","toDateEventConfig","toDate","endDate","getDate","fromDateLabel","toDateLabel","addComponent","availableWidth","availableHeight","logicalSpace","getLogicalSpace","add","name","ref","priority","type","dimensions","parent","getParentComponentGroup","getWidth","getHeight","x","y","mes","parentGroup","ln","draw","onPropsChange","start","end","createErrorGroup","maxXAxisTicks","minDatestampDiff","minActiveInterval","containerRight","clientLeft","clientWidth","containerBottom","clientTop","clientHeight","get","set","getTimestamp","newDate","isBetween","isBeforeOrEqualTo","diffIsGreaterThan","isAfterOrEqualTo"],"mappings":"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","file":"date-range-chooser-es5.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar DateRange = __webpack_require__(2);\n\t\n\t;(function (env, factory) {\n\t  if (( false ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t    module.exports = env.document ? factory(env) : function (win) {\n\t      if (!win.document) {\n\t        throw new Error('Window with document not present');\n\t      }\n\t      return factory(win, true);\n\t    };\n\t  } else {\n\t    env.DateRangeChooser = factory(env, true);\n\t  }\n\t})(typeof window !== 'undefined' ? window : undefined, function (_window, windowExists) {\n\t  var FC = _window.FusionCharts;\n\t  FC.register('extension', ['private', 'date-range-chooser', function () {\n\t    var DateTimeFormatter = this.hcLib.DateTimeFormatter;\n\t    FC.registerComponent('extensions', 'date-range-chooser', DateRange({ FusionCharts: FC,\n\t      DateTimeFormatter: DateTimeFormatter }));\n\t  }]);\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function (dep) {\n\t\n\t  // Merge two objects recursively\n\t  function mergeRecursive(source, sink) {\n\t    var prop;\n\t\n\t    for (prop in sink) {\n\t\n\t      if (source[prop] instanceof Object) {\n\t        mergeRecursive(source[prop], sink[prop]);\n\t      } else {\n\t        source[prop] = sink[prop];\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Class representing the DateRange.\n\t   */\n\t\n\t  var DateRange = function () {\n\t    function DateRange() {\n\t      _classCallCheck(this, DateRange);\n\t\n\t      /**\n\t       * @private\n\t       */\n\t      this.startDt = 0;\n\t      this.endDt = 0;\n\t      this.startDataset = 0;\n\t      this.endDataset = 0;\n\t      if (typeof dep.FusionCharts === 'function') {\n\t        this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');\n\t      } else {\n\t        throw new Error('Unable to find FusionCharts.');\n\t      }\n\t      if (typeof dep.FusionCharts === 'function') {\n\t        this.DateTimeFormatter = dep.DateTimeFormatter;\n\t      } else {\n\t        throw new Error('Unable to find DateTimeFormatter.');\n\t      }\n\t      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;\n\t      this.ComponentGroup = this.toolbox.ComponentGroup;\n\t      this.isDrawn = false;\n\t      this.startTooltipErrorMsg = '';\n\t      this.endTooltipErrorMsg = '';\n\t      this.createObjectAssign();\n\t    }\n\t\n\t    /**\n\t     * An object representing the start and end dates.\n\t     * @type {DateRange.range}\n\t     */\n\t\n\t\n\t    _createClass(DateRange, [{\n\t      key: 'isBeforeOrEqualTo',\n\t      value: function isBeforeOrEqualTo(startTimestamp, endTimestamp, errorType) {\n\t        if (startTimestamp <= endTimestamp) {\n\t          return true;\n\t        } else {\n\t          this.startTooltipErrorMsg = '<span style=\"color: ' + this.config.styles['input-error-tooltip-font-color'] + '\">Date must be less than end date!</span>';\n\t          if (errorType === 'from') {\n\t            this.setErrorMsg(this.fromError, 'Date must be less than end date!');\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'isAfterOrEqualTo',\n\t      value: function isAfterOrEqualTo(endTimestamp, startTimestamp, errorType) {\n\t        if (endTimestamp >= startTimestamp) {\n\t          return true;\n\t        } else {\n\t          this.endTooltipErrorMsg = '<span style=\"color: ' + this.config.styles['input-error-tooltip-font-color'] + '\">Date must be greater than start date!</span>';\n\t          if (errorType === 'to') {\n\t            this.setErrorMsg(this.toError, 'Date must be greater than start date!');\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'isBetween',\n\t      value: function isBetween(timestamp, absoluteStart, absoluteEnd, errorType) {\n\t        if (timestamp >= absoluteStart && timestamp <= absoluteEnd) {\n\t          return true;\n\t        } else {\n\t          this.startTooltipErrorMsg = this.endTooltipErrorMsg = '<span style=\"color: ' + this.config.styles['input-error-tooltip-font-color'] + '\">Date out of bounds!</span>';\n\t          if (errorType === 'from') {\n\t            this.setErrorMsg(this.fromError, 'Date out of bounds!');\n\t          } else if (errorType === 'to') {\n\t            this.setErrorMsg(this.toError, 'Date out of bounds!');\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'diffIsGreaterThan',\n\t      value: function diffIsGreaterThan(actualDiff, minDiff, errorType) {\n\t        if (actualDiff > minDiff) {\n\t          return true;\n\t        } else {\n\t          this.startTooltipErrorMsg = this.endTooltipErrorMsg = '<span style=\"color: ' + this.config.styles['input-error-tooltip-font-color'] + '\">Zoom limit exceeded!</span>';\n\t          if (errorType === 'from') {\n\t            this.setErrorMsg(this.fromError, 'Zoom limit exceeded!');\n\t          } else if (errorType === 'to') {\n\t            this.setErrorMsg(this.toError, 'Zoom limit exceeded!');\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'getTimestamp',\n\t      value: function getTimestamp(dateStr) {\n\t        var dateFormat = this.config.dateFormat,\n\t            dateFormatter = new dep.DateTimeFormatter(dateFormat);\n\t        return +dateFormatter.getNativeDate(dateStr);\n\t      }\n\t    }, {\n\t      key: 'getDate',\n\t      value: function getDate(timestamp) {\n\t        var dateFormat = this.config.dateFormat;\n\t        return this.DateTimeFormatter.formatAs(timestamp, dateFormat);\n\t      }\n\t\n\t      /**\n\t       * Sets the configurable options of the extension (e.g. cosmetics)\n\t       * @param {Object} configObj The configuration object containing various extension options\n\t       */\n\t\n\t    }, {\n\t      key: 'setConfig',\n\t      value: function setConfig(configObj) {}\n\t\n\t      /**\n\t       * Gets the configurable options of the extension (e.g. cosmetics)\n\t       * @return {object} configObj The configuration object containing various extension options\n\t       */\n\t\n\t    }, {\n\t      key: 'getConfig',\n\t      value: function getConfig() {\n\t        return {\n\t          calendarVisible: 'false'\n\t        };\n\t      }\n\t    }, {\n\t      key: 'createConfig',\n\t      value: function createConfig(extData) {\n\t        var config = {},\n\t            defaultStyles = {\n\t\n\t          inputButton: {\n\t            'width': 120,\n\t            'height': 22,\n\t            radius: 1,\n\t            padding: {\n\t              left: 15,\n\t              right: 10\n\t            },\n\t            className: 'date-range-chooser',\n\t            container: {\n\t              style: {\n\t                fill: '#FFFFFF',\n\t                'stroke-width': 1,\n\t                stroke: '#CED5D4'\n\t                // 'input-shadow-fill': '#000000',\n\t                // 'input-shadow-opacity': 0.35,\n\t              }\n\t            },\n\t            text: {\n\t              style: {\n\t                'font-family': '\"Lucida Grande\", sans-serif',\n\t                'font-size': '13px',\n\t                fill: '#4B4B4B'\n\t              }\n\t            },\n\t            states: {\n\t              selected: {\n\t                className: 'date-range-chooser-state-selected',\n\t                container: {\n\t                  style: {\n\t                    fill: '#FFFFFF',\n\t                    stroke: '#1E1F1F'\n\t                  }\n\t                }\n\t              },\n\t              errored: {\n\t                className: 'date-range-chooser-state-errored',\n\t                container: {\n\t                  style: {\n\t                    fill: '#FFFFFF',\n\t                    stroke: '#D25353'\n\t                  }\n\t                }\n\t                // 'input-error-tooltip-font-color': '#FF0000'\n\t              }\n\t            }\n\t          },\n\t          label: {\n\t            className: 'date-range-chooser-label',\n\t            text: {\n\t              style: {\n\t                'font-family': '\"Lucida Grande\", sans-serif',\n\t                'font-size': '13px',\n\t                fill: '#4B4B4B'\n\t              }\n\t            }\n\t          }\n\t        };\n\t        config.disabled = extData.disabled || false;\n\t        config.layout = extData.layout || 'inline';\n\t        config.orientation = extData.orientation || 'horizontal';\n\t        config.position = extData.position || 'top';\n\t        config.alignment = extData.alignment || 'right';\n\t        config.dateFormat = extData.dateFormat || '%d-%m-%Y';\n\t        config.fromText = extData.fromText || 'From:';\n\t        config.fromTooltipText = extData.fromTooltipText || 'From Date';\n\t        config.toText = extData.toText || 'To:';\n\t        config.toTooltipText = extData.toTooltipText || 'To Date';\n\t        config.styles = Object.assign(defaultStyles, extData.styles);\n\t        return config;\n\t      }\n\t    }, {\n\t      key: 'createErrorGroup',\n\t      value: function createErrorGroup(symbol) {\n\t        // return;\n\t        //   let self = this,\n\t        //     paper = self.graphics.paper,\n\t        //     circle,\n\t        //     crossPath,\n\t        //     cross,\n\t        //     rect,\n\t        //     text,\n\t        //     group,\n\t        //     textBBox,\n\t        //     circleBBox,\n\t        //     rectBBox,\n\t        //     symbolBBox,\n\t        //     orientation = self.config.orientation,\n\t        //     position = self.config.position;\n\t\n\t        //   if (orientation === 'horizontal') {\n\t        //     if (position === 'top') {\n\t        //       symbolBBox = symbol.getBoundElement().getBBox();\n\t        //       group = paper.group('error-group');\n\t\n\t        //       rect = paper.rect(symbolBBox.x,\n\t        //         symbolBBox.y - symbolBBox.height, 20, 20, group);\n\t        //       rectBBox = rect.getBBox();\n\t\n\t        //       circle = paper.circle(rectBBox.x + 5 + 1,\n\t        //         rectBBox.y + 6 + 4, 6, group);\n\t        //       circleBBox = circle.getBBox();\n\t\n\t        //       crossPath = this.getCrossPath(circleBBox, 4);\n\t        //       cross = paper.path(crossPath, group);\n\t\n\t        //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n\t        //         '', group);\n\t        //       textBBox = text.getBBox();\n\t        //     } else if (position === 'bottom') {\n\t        //       symbolBBox = symbol.getBoundElement().getBBox();\n\t        //       group = paper.group('error-group');\n\t\n\t        //       rect = paper.rect(symbolBBox.x,\n\t        //         symbolBBox.y + symbolBBox.height, 20, 20, group);\n\t        //       rectBBox = rect.getBBox();\n\t\n\t        //       circle = paper.circle(rectBBox.x + 5 + 1,\n\t        //         rectBBox.y + 6 + 4, 6, group);\n\t        //       circleBBox = circle.getBBox();\n\t\n\t        //       crossPath = this.getCrossPath(circleBBox, 4);\n\t        //       cross = paper.path(crossPath, group);\n\t\n\t        //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n\t        //         '', group);\n\t        //       textBBox = text.getBBox();\n\t        //     }\n\t        //   } else if (orientation === 'vertical') {\n\t        //     symbolBBox = symbol.getBoundElement().getBBox();\n\t        //     group = paper.group('error-group');\n\t\n\t        //     rect = paper.rect(symbolBBox.x,\n\t        //       symbolBBox.y + symbolBBox.height, 20, 20, group);\n\t        //     rectBBox = rect.getBBox();\n\t\n\t        //     circle = paper.circle(rectBBox.x + 5 + 1,\n\t        //       rectBBox.y + 6 + 4, 6, group);\n\t        //     circleBBox = circle.getBBox();\n\t\n\t        //     crossPath = this.getCrossPath(circleBBox, 4);\n\t        //     cross = paper.path(crossPath, group);\n\t\n\t        //     text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n\t        //       '', group);\n\t        //     textBBox = text.getBBox();\n\t        //   }\n\t\n\t        //   circle.attr({\n\t        //     'stroke': '#d71f26',\n\t        //     'stroke-width': '1',\n\t        //     'fill': 'none'\n\t        //   });\n\t        //   cross.attr({\n\t        //     'stroke': '#000000',\n\t        //     'stroke-width': '1.5'\n\t        //   });\n\t        //   text.attr({\n\t        //     'text-anchor': 'start',\n\t        //     'y': textBBox.y + textBBox.height,\n\t        //     'fill': '#D80000',\n\t        //     'font-family': '\"Lucida Grande\", sans-serif',\n\t        //     'font-size': '12'\n\t        //   });\n\t        //   rect.attr({\n\t        //     'fill': '#FFFFFF',\n\t        //     'fill-opacity': '0.8',\n\t        //     'stroke-width': '0',\n\t        //     'width': textBBox.width + circleBBox.width\n\t        //   });\n\t        //   group.attr({\n\t        //     visibility: 'hidden'\n\t        //   });\n\t\n\t        //   return {\n\t        //     'group': group,\n\t        //     'cross': cross,\n\t        //     'circle': circle,\n\t        //     'rect': rect,\n\t        //     'text': text\n\t        //   };\n\t        // }\n\t\n\t        // getCrossPath (circleBox, padding) {\n\t        //   // M478,77L483,82M478,82L483,77\n\t        //   let circleX1 = Math.round(circleBox.x),\n\t        //     circleY1 = Math.round(circleBox.y),\n\t        //     circleX2 = Math.round(circleBox.x2),\n\t        //     circleY2 = Math.round(circleBox.y2),\n\t        //     crossX1 = circleX1 + 4,\n\t        //     crossY1 = circleY1 + 2,\n\t        //     crossX2 = circleX2 - 4,\n\t        //     crossY2 = circleY2 - 3,\n\t        //     pathStr = 'M' + crossX1 + ',' + crossY1 + 'L' + crossX2 + ',' + crossY2;\n\t        //   pathStr += 'M' + crossX1 + ',' + crossY2 + 'L' + crossX2 + ',' + crossY1;\n\t        //   return pathStr;\n\t      }\n\t    }, {\n\t      key: 'setErrorMsg',\n\t      value: function setErrorMsg(errorGroup, errorMsg) {\n\t        // return;\n\t        // let errorRectX,\n\t        //   errorRectWidth,\n\t        //   errorRectEnd;\n\t\n\t        // if (errorGroup.text.attr('text') === errorMsg) {\n\t        //   return;\n\t        // }\n\t        // errorGroup.text.attr('text', errorMsg);\n\t        // errorGroup.rect.attr('width',\n\t        //   errorGroup.text.getBBox().width + (4 * 2) + errorGroup.circle.getBBox().width + 2);\n\t\n\t        // errorRectX = errorGroup.rect.getBBox().x;\n\t        // errorRectWidth = errorGroup.rect.getBBox().width;\n\t        // errorRectEnd = errorRectX + errorRectWidth;\n\t        // console.log(errorRectEnd, this.containerRight);\n\t        // if (errorRectEnd > this.containerRight) {\n\t        //   let diff = errorRectEnd - this.containerRight;\n\t        //   errorGroup.rect.attr('x', errorRectX - diff);\n\t        //   errorGroup.circle.attr('cx', errorGroup.circle.getBBox().x - diff + 5);\n\t        //   errorGroup.cross.translate(-diff - 1, 0);\n\t        //   errorGroup.text.attr('x', errorGroup.text.getBBox().x - diff);\n\t        // }\n\t      }\n\t    }, {\n\t      key: 'createObjectAssign',\n\t      value: function createObjectAssign() {\n\t        if (typeof Object.assign !== 'function') {\n\t          Object.assign = function (target, varArgs) {\n\t            'use strict';\n\t\n\t            if (target == null) {\n\t              throw new TypeError('Cannot convert undefined or null to object');\n\t            }\n\t\n\t            var to = Object(target);\n\t\n\t            for (var index = 1; index < arguments.length; index++) {\n\t              var nextSource = arguments[index];\n\t\n\t              if (nextSource != null) {\n\t                for (var nextKey in nextSource) {\n\t                  // Avoid bugs when hasOwnProperty is shadowed\n\t                  if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t                    to[nextKey] = nextSource[nextKey];\n\t                  }\n\t                }\n\t              }\n\t            }\n\t            return to;\n\t          };\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Fusioncharts life cycle method for extension\n\t       */\n\t\n\t    }, {\n\t      key: 'init',\n\t      value: function init(require) {\n\t        var instance = this;\n\t        require(['xAxis', 'graphics', 'chart', 'dataset', 'globalReactiveModel', 'spaceManagerInstance', 'extData', 'smartLabel', 'chartInstance', function (xAxis, graphics, chart, dataset, globalReactiveModel, spaceManagerInstance, extData, smartLabel, chartInstance) {\n\t          instance.xAxis = xAxis;\n\t          instance.graphics = graphics;\n\t          instance.chart = chart;\n\t          instance.dataset = dataset;\n\t          instance.globalReactiveModel = globalReactiveModel;\n\t          instance.spaceManagerInstance = spaceManagerInstance;\n\t          instance.config = instance.createConfig(extData);\n\t          instance.smartLabel = smartLabel;\n\t          instance.chartInstance = chartInstance;\n\t        }]);\n\t        instance.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];\n\t        instance.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];\n\t        instance.toolbars = [];\n\t        instance.measurement = {};\n\t        instance.toolbars.push(instance.createToolbar());\n\t        return instance;\n\t      }\n\t    }, {\n\t      key: 'createToolbar',\n\t      value: function createToolbar() {\n\t        var toolbar,\n\t            self = this,\n\t            fromDateLabel,\n\t            toDateLabel,\n\t            fromGroup,\n\t            toGroup,\n\t            fromFormattedDate,\n\t            toFormattedDate,\n\t            styles = this.config.styles,\n\t            inputBtnStyles = styles.inputButton,\n\t            paper = this.graphics.paper,\n\t            classNames,\n\t            addCssRules = function addCssRules(classNames, styles) {\n\t          var key, className;\n\t          for (key in classNames) {\n\t            className = classNames[key];\n\t            switch (key) {\n\t              case 'container':\n\t                styles.container && paper.cssAddRule('.' + className, styles.container.style);\n\t                break;\n\t              case 'input':\n\t                styles.text && paper.cssAddRule('.' + className, {\n\t                  color: styles.text.style.fill,\n\t                  'font-family': styles.text.style['font-family'],\n\t                  'font-size': styles.text.style['font-size']\n\t                });\n\t                break;\n\t              case 'text':\n\t                styles.text && paper.cssAddRule('.' + className, styles.text.style);\n\t            }\n\t          }\n\t        },\n\t            createInputButtons = function createInputButtons(store) {\n\t          var key, inputButton, text, config, states, state;\n\t\n\t          for (key in store) {\n\t            inputButton = store[key];\n\t            text = inputButton.text;\n\t            config = inputButton.config;\n\t            self[key] = d3.inputButton(text).setConfig(config);\n\t            self[key].namespace('fusioncharts');\n\t            self[key].appendSelector('daterange');\n\t            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), inputBtnStyles);\n\t            states = config.states;\n\t            for (state in states) {\n\t              addCssRules(self[key].getIndividualClassNames(self[key].config.states[state]), inputBtnStyles.states[state]);\n\t            }\n\t\n\t            self[key].attachEventHandlers(inputButton.eventListeners);\n\t            inputButton.group.addSymbol(self[key]);\n\t          }\n\t        },\n\t            createLabels = function createLabels(store) {\n\t          var key, label, text, config;\n\t\n\t          for (key in store) {\n\t            label = store[key];\n\t            text = label.text;\n\t            config = label.config;\n\t            self[key] = new self.toolbox.Label(text, dependencies, config);\n\t            // self[key].namespace('fusioncharts');\n\t            // self[key].appendSelector('daterange');\n\t            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), label.styles);\n\t            label.group.addSymbol(self[key]);\n\t          }\n\t        },\n\t            dependencies = {\n\t          paper: this.graphics.paper,\n\t          chart: this.chart,\n\t          smartLabel: this.smartLabel,\n\t          chartContainer: this.graphics.container\n\t        },\n\t            fromDateEventConfig = {\n\t          click: function click() {\n\t            // if (self.fromDate.state === 'errored' &&\n\t            //   self.fromError.text.attr('text') !== '') {\n\t            //   self.toError.group.hide();\n\t            //   self.fromError.group.show();\n\t            // }\n\t            self.fromDate.setState('selected');\n\t          },\n\t          // tooltext: self.config.fromTooltipText,\n\t          keypress: function keypress(e) {\n\t            var event = e || window.event,\n\t                charCode = event.which || event.keyCode;\n\t            if (charCode === 13) {\n\t              self.startDate = self.fromDate.text();\n\t              if (self.fromDate.state !== 'errored') {\n\t                self.fromDate.blur();\n\t                // self.fromError.group.hide();\n\t                // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n\t                // self.fromDate.removeState('selected');\n\t                // self.fromDate.removeState('errored');\n\t              } else {\n\t                  // self.fromError.group.show();\n\t                  // self.fromDate.state = 'errored';\n\t                  // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n\t                }\n\t            }\n\t          },\n\t          blur: function blur() {\n\t            self.startDate = self.fromDate.text();\n\t            if (self.fromDate.state !== 'errored') {\n\t              self.fromDate.blur();\n\t              // self.fromError.group.hide();\n\t              // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n\t              self.fromDate.removeState('selected');\n\t            } else {\n\t              // self.fromError.group.show();\n\t              // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n\t            }\n\t          }\n\t        },\n\t            toDateEventConfig = {\n\t          click: function click() {\n\t            // if (self.toDate.state === 'errored' &&\n\t            //   self.toError.text.attr('text') !== '') {\n\t            //   self.fromError.group.hide();\n\t            //   self.toError.group.show();\n\t            // }\n\t            // self.toDate.edit();\n\t            self.toDate.setState('selected');\n\t          },\n\t          // tooltext: self.config.toTooltipText,\n\t          keypress: function keypress(e) {\n\t            var event = e || window.event,\n\t                charCode = event.which || event.keyCode;\n\t            if (charCode === 13) {\n\t              self.endDate = self.toDate.text();\n\t              if (self.toDate.state !== 'errored') {\n\t                self.toDate.blur();\n\t                // self.toError.group.hide();\n\t                // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n\t                self.toDate.removeState('selected');\n\t              } else {\n\t                // self.toError.group.show();\n\t                // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n\t              }\n\t            }\n\t          },\n\t          blur: function blur() {\n\t            // self.toDate.blur();\n\t            self.endDate = self.toDate.text();\n\t            if (self.toDate.state !== 'errored') {\n\t              // self.toDate.blur();\n\t              // self.toError.group.hide();\n\t              // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n\t              self.toDate.removeState('selected');\n\t            } else {\n\t              // self.toError.group.show();\n\t              // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n\t            }\n\t          }\n\t        },\n\t            labelList,\n\t            inputButtonlist;\n\t\n\t        self.fromDate = {};\n\t        self.toDate = {};\n\t\n\t        fromFormattedDate = this.getDate(this.startDt);\n\t        toFormattedDate = this.getDate(this.endDt);\n\t        toolbar = new this.HorizontalToolbar(dependencies);\n\t\n\t        fromGroup = new this.toolbox.ComponentGroup(dependencies);\n\t\n\t        toGroup = new this.toolbox.ComponentGroup(dependencies);\n\t\n\t        labelList = {\n\t          fromDateLabel: {\n\t            text: this.config['fromText'],\n\t            config: {\n\t              className: styles.label.className,\n\t              container: {\n\t                'width': 40\n\t              }\n\t            },\n\t            styles: styles.label,\n\t            group: fromGroup\n\t          },\n\t          toDateLabel: {\n\t            text: this.config['toText'],\n\t            config: {\n\t              className: styles.label.className,\n\t              container: {\n\t                'width': 40\n\t              }\n\t            },\n\t            styles: styles.label,\n\t            group: toGroup\n\t          }\n\t        };\n\t\n\t        inputButtonlist = {\n\t          fromDate: {\n\t            text: fromFormattedDate,\n\t            config: {\n\t              width: inputBtnStyles.width,\n\t              height: inputBtnStyles.height,\n\t              padding: inputBtnStyles.padding,\n\t              radius: inputBtnStyles.radius,\n\t              className: inputBtnStyles.className,\n\t              states: {\n\t                selected: inputBtnStyles.states.selected.className,\n\t                errored: inputBtnStyles.states.errored.className\n\t              }\n\t            },\n\t            eventListeners: fromDateEventConfig,\n\t            group: fromGroup\n\t          },\n\t          toDate: {\n\t            text: toFormattedDate,\n\t            config: {\n\t              width: inputBtnStyles.width,\n\t              height: inputBtnStyles.height,\n\t              padding: inputBtnStyles.padding,\n\t              radius: inputBtnStyles.radius,\n\t              className: inputBtnStyles.className,\n\t              states: {\n\t                selected: inputBtnStyles.states.selected.className,\n\t                errored: inputBtnStyles.states.errored.className\n\t              }\n\t            },\n\t            eventListeners: toDateEventConfig,\n\t            group: toGroup\n\t          }\n\t        };\n\t\n\t        createLabels(labelList);\n\t        createInputButtons(inputButtonlist);\n\t\n\t        toolbar.addComponent(fromGroup);\n\t        toolbar.addComponent(toGroup);\n\t        return toolbar;\n\t      }\n\t    }, {\n\t      key: 'getLogicalSpace',\n\t      value: function getLogicalSpace(availableWidth, availableHeight) {\n\t        var logicalSpace = this.toolbars[0].getLogicalSpace(availableWidth, availableHeight);\n\t        this.toolbars[0].width = logicalSpace.width;\n\t        this.toolbars[0].height = logicalSpace.height;\n\t        return {\n\t          width: logicalSpace.width,\n\t          height: logicalSpace.height\n\t        };\n\t      }\n\t    }, {\n\t      key: 'placeInCanvas',\n\t      value: function placeInCanvas() {\n\t        var _self = this;\n\t        _self.spaceManagerInstance.add([{\n\t          name: function name() {\n\t            return 'DateRangeChooserToolbox';\n\t          },\n\t          ref: function ref(obj) {\n\t            return obj['0'];\n\t          },\n\t          self: function self() {\n\t            return _self;\n\t          },\n\t          priority: function priority() {\n\t            return 2;\n\t          },\n\t          layout: function layout(obj) {\n\t            return obj[_self.config.layout];\n\t          },\n\t          orientation: [{\n\t            type: function type(obj) {\n\t              return obj[_self.config.orientation];\n\t            },\n\t            position: [{\n\t              type: function type(obj) {\n\t                return obj[_self.config.position];\n\t              },\n\t              alignment: [{\n\t                type: function type(obj) {\n\t                  return obj[_self.config.alignment];\n\t                },\n\t                dimensions: [function () {\n\t                  var parent = this.getParentComponentGroup();\n\t                  return _self.getLogicalSpace(parent.getWidth(), parent.getHeight());\n\t                }]\n\t              }]\n\t            }]\n\t          }]\n\t        }]);\n\t      }\n\t    }, {\n\t      key: 'setDrawingConfiguration',\n\t      value: function setDrawingConfiguration(x, y, width, height, group) {\n\t        var mes = this.measurement;\n\t        mes.x = x;\n\t        mes.y = y;\n\t        mes.width = width;\n\t        mes.height = height;\n\t\n\t        this.parentGroup = group;\n\t\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'draw',\n\t      value: function draw(x, y, width, height, group) {\n\t        var self = this,\n\t            measurement = self.measurement,\n\t            toolbars = self.toolbars,\n\t            ln = void 0,\n\t            i = void 0,\n\t            toolbar = void 0,\n\t            model = self.globalReactiveModel;\n\t\n\t        x = x === undefined ? measurement.x : x;\n\t        y = y === undefined ? measurement.y : y;\n\t        width = width === undefined ? measurement.width : width;\n\t        height = height === undefined ? measurement.height : height;\n\t        group = group === undefined ? self.parentGroup : group;\n\t        if (width && height) {\n\t          self.isDrawn = true;\n\t          for (i = 0, ln = toolbars.length; i < ln; i++) {\n\t            toolbar = toolbars[i];\n\t            toolbar.draw(x, y, group);\n\t          }\n\t          model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'], function (start, end) {\n\t            // setTimeout(() => {\n\t            self.startDt = start[1];\n\t            self.fromDate.text(self.getDate(start[1]));\n\t            // self.fromDate.blur(self.getDate(start[1]));\n\t            // self.fromError.text.attr('text', '');\n\t            // self.fromError.group.hide();\n\t            // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n\t            self.fromDate.removeState('selected');\n\t            self.fromDate.removeState('errored');\n\t            self.endDt = end[1];\n\t            self.toDate.text(self.getDate(end[1]));\n\t            // self.toDate.blur(self.getDate(end[1]));\n\t            // self.toError.text.attr('text', '');\n\t            // self.toError.group.hide();\n\t            // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n\t            self.toDate.removeState('selected');\n\t            self.toDate.removeState('errored');\n\t            // }, 400);\n\t          });\n\t        }\n\t\n\t        if (self.config.orientation === 'vertical') {\n\t          self.fromError = self.createErrorGroup(self.toDate);\n\t          self.toError = self.createErrorGroup(self.toDate);\n\t        } else if (self.config.orientation === 'horizontal') {\n\t          self.fromError = self.createErrorGroup(self.fromDate);\n\t          self.toError = self.createErrorGroup(self.toDate);\n\t        }\n\t        self.startDataset = self.globalReactiveModel.model['x-axis-absolute-range-start'];\n\t        self.endDataset = self.globalReactiveModel.model['x-axis-absolute-range-end'];\n\t        self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n\t        self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n\t        self.minDatestampDiff = self.globalReactiveModel.model['minimum-consecutive-datestamp-diff'];\n\t        self.minActiveInterval = self.maxXAxisTicks * self.minDatestampDiff;\n\t        self.containerRight = self.graphics.container.clientLeft + self.graphics.container.clientWidth;\n\t        self.containerBottom = self.graphics.container.clientTop + self.graphics.container.clientHeight;\n\t      }\n\t    }, {\n\t      key: 'startDate',\n\t      get: function get() {\n\t        return this.startDt;\n\t      },\n\t      set: function set(startDt) {\n\t        var startTimestamp = this.getTimestamp(startDt),\n\t            newDate = this.getDate(this.startDt),\n\t            absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n\t            absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n\t            minDiff = this.minActiveInterval,\n\t            actualDiff = this.endDt - startTimestamp;\n\t        if (newDate !== startDt) {\n\t          if (this.isBetween(startTimestamp, absoluteStart, absoluteEnd, 'from') && this.isBeforeOrEqualTo(startTimestamp, this.endDt, 'from') && this.diffIsGreaterThan(actualDiff, minDiff, 'from')) {\n\t            this.startDt = startTimestamp;\n\t            this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;\n\t          } else {\n\t            // this.toError.group.hide();\n\t            this.fromDate.setState('errored');\n\t            this.fromDate.state = 'errored';\n\t          }\n\t        } else {\n\t          if (this.fromDate.state === 'errored') {\n\t            this.fromDate.removeState('errored');\n\t            this.fromDate.state = 'enabled';\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: 'endDate',\n\t      get: function get() {\n\t        return this.endDt;\n\t      },\n\t      set: function set(endDt) {\n\t        var endTimestamp = this.getTimestamp(endDt),\n\t            newDate = this.getDate(this.endDt),\n\t            absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n\t            absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n\t            minDiff = this.minActiveInterval,\n\t            actualDiff = endTimestamp - this.startDt;\n\t\n\t        if (newDate !== endDt) {\n\t          if (this.isBetween(endTimestamp, absoluteStart, absoluteEnd, 'to') && this.isAfterOrEqualTo(endTimestamp, this.startDt, 'to') && this.diffIsGreaterThan(actualDiff, minDiff, 'to')) {\n\t            this.endDt = endTimestamp;\n\t            this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;\n\t          } else {\n\t            // this.fromError.group.hide();\n\t            this.toDate.setState('errored');\n\t            this.toDate.state = 'errored';\n\t          }\n\t        } else {\n\t          if (this.toDate.state === 'errored') {\n\t            this.toDate.removeState('errored');\n\t            this.toDate.state = 'enabled';\n\t          }\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return DateRange;\n\t  }();\n\t\n\t  return DateRange;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// date-range-chooser-es5.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d8569594dd1e378a0549","'use strict';\nconst DateRange = require('./fcts-ext-daterange');\n\n;(function (env, factory) {\n  if (typeof module === 'object' && module.exports) {\n    module.exports = env.document\n       ? factory(env) : function (win) {\n         if (!win.document) {\n           throw new Error('Window with document not present');\n         }\n         return factory(win, true);\n       };\n  } else {\n    env.DateRangeChooser = factory(env, true);\n  }\n})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {\n  var FC = _window.FusionCharts;\n  FC.register('extension', ['private', 'date-range-chooser', function () {\n    var DateTimeFormatter = this.hcLib.DateTimeFormatter;\n    FC.registerComponent('extensions', 'date-range-chooser', DateRange({FusionCharts: FC,\n      DateTimeFormatter: DateTimeFormatter}));\n  }]);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 1\n// module chunks = 0","'use strict';\nmodule.exports = function (dep) {\n\n  // Merge two objects recursively\n  function mergeRecursive (source, sink) {\n      var prop;\n\n      for (prop in sink) {\n\n          if (source[prop] instanceof Object) {\n              mergeRecursive(source[prop], sink[prop]);\n          }\n          else {\n              source[prop] = sink[prop];\n          }\n      }\n  }\n\n  /**\n   * Class representing the DateRange.\n   */\n  class DateRange {\n    constructor () {\n      /**\n       * @private\n       */\n      this.startDt = 0;\n      this.endDt = 0;\n      this.startDataset = 0;\n      this.endDataset = 0;\n      if (typeof dep.FusionCharts === 'function') {\n        this.toolbox = dep.FusionCharts.getComponent('api', 'toolbox');\n      } else {\n        throw new Error('Unable to find FusionCharts.');\n      }\n      if (typeof dep.FusionCharts === 'function') {\n        this.DateTimeFormatter = dep.DateTimeFormatter;\n      } else {\n        throw new Error('Unable to find DateTimeFormatter.');\n      }\n      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;\n      this.ComponentGroup = this.toolbox.ComponentGroup;\n      this.isDrawn = false;\n      this.startTooltipErrorMsg = '';\n      this.endTooltipErrorMsg = '';\n      this.createObjectAssign();\n    }\n\n    /**\n     * An object representing the start and end dates.\n     * @type {DateRange.range}\n     */\n    get startDate () {\n      return this.startDt;\n    }\n\n    set startDate (startDt) {\n      let startTimestamp = this.getTimestamp(startDt),\n        newDate = this.getDate(this.startDt),\n        absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n        absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n        minDiff = this.minActiveInterval,\n        actualDiff = this.endDt - startTimestamp;\n      if (newDate !== startDt) {\n        if (this.isBetween(startTimestamp, absoluteStart, absoluteEnd, 'from') &&\n          this.isBeforeOrEqualTo(startTimestamp, this.endDt, 'from') &&\n          this.diffIsGreaterThan(actualDiff, minDiff, 'from')) {\n          this.startDt = startTimestamp;\n          this.globalReactiveModel.model['x-axis-visible-range-start'] = this.startDt;\n        } else {\n          // this.toError.group.hide();\n          this.fromDate.setState('errored');\n          this.fromDate.state = 'errored';\n        }\n      } else {\n        if (this.fromDate.state === 'errored') {\n          this.fromDate.removeState('errored');\n          this.fromDate.state = 'enabled';\n        }\n      }\n    }\n\n    isBeforeOrEqualTo (startTimestamp, endTimestamp, errorType) {\n      if (startTimestamp <= endTimestamp) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date must be less than end date!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Date must be less than end date!');\n        }\n        return false;\n      }\n    }\n\n    get endDate () {\n      return this.endDt;\n    }\n\n    set endDate (endDt) {\n      let endTimestamp = this.getTimestamp(endDt),\n        newDate = this.getDate(this.endDt),\n        absoluteStart = this.globalReactiveModel.model['x-axis-absolute-range-start'],\n        absoluteEnd = this.globalReactiveModel.model['x-axis-absolute-range-end'],\n        minDiff = this.minActiveInterval,\n        actualDiff = endTimestamp - this.startDt;\n\n      if (newDate !== endDt) {\n        if (this.isBetween(endTimestamp, absoluteStart, absoluteEnd, 'to') &&\n          this.isAfterOrEqualTo(endTimestamp, this.startDt, 'to') &&\n          this.diffIsGreaterThan(actualDiff, minDiff, 'to')) {\n          this.endDt = endTimestamp;\n          this.globalReactiveModel.model['x-axis-visible-range-end'] = this.endDt;\n        } else {\n          // this.fromError.group.hide();\n          this.toDate.setState('errored');\n          this.toDate.state = 'errored';\n        }\n      } else {\n        if (this.toDate.state === 'errored') {\n          this.toDate.removeState('errored');\n          this.toDate.state = 'enabled';\n        }\n      }\n    }\n\n    isAfterOrEqualTo (endTimestamp, startTimestamp, errorType) {\n      if (endTimestamp >= startTimestamp) {\n        return true;\n      } else {\n        this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date must be greater than start date!</span>';\n        if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Date must be greater than start date!');\n        }\n        return false;\n      }\n    }\n\n    isBetween (timestamp, absoluteStart, absoluteEnd, errorType) {\n      if (timestamp >= absoluteStart && timestamp <= absoluteEnd) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg = this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Date out of bounds!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Date out of bounds!');\n        } else if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Date out of bounds!');\n        }\n        return false;\n      }\n    }\n\n    diffIsGreaterThan (actualDiff, minDiff, errorType) {\n      if (actualDiff > minDiff) {\n        return true;\n      } else {\n        this.startTooltipErrorMsg = this.endTooltipErrorMsg =\n        '<span style=\"color: ' +\n        this.config.styles['input-error-tooltip-font-color'] +\n        '\">Zoom limit exceeded!</span>';\n        if (errorType === 'from') {\n          this.setErrorMsg(this.fromError, 'Zoom limit exceeded!');\n        } else if (errorType === 'to') {\n          this.setErrorMsg(this.toError, 'Zoom limit exceeded!');\n        }\n        return false;\n      }\n    }\n\n    getTimestamp (dateStr) {\n      let dateFormat = this.config.dateFormat,\n        dateFormatter = new dep.DateTimeFormatter(dateFormat);\n      return +dateFormatter.getNativeDate(dateStr);\n    }\n\n    getDate (timestamp) {\n      var dateFormat = this.config.dateFormat;\n      return this.DateTimeFormatter.formatAs(timestamp, dateFormat);\n    }\n\n    /**\n     * Sets the configurable options of the extension (e.g. cosmetics)\n     * @param {Object} configObj The configuration object containing various extension options\n     */\n    setConfig (configObj) {}\n\n    /**\n     * Gets the configurable options of the extension (e.g. cosmetics)\n     * @return {object} configObj The configuration object containing various extension options\n     */\n    getConfig () {\n      return {\n        calendarVisible: 'false'\n      };\n    }\n\n    createConfig (extData) {\n      let config = {},\n        defaultStyles = {\n\n          inputButton: {\n            'width': 120,\n            'height': 22,\n            radius: 1,\n            padding: {\n              left: 15,\n              right: 10\n            },\n            className: 'date-range-chooser',\n            container: {\n              style: {\n                fill: '#FFFFFF',\n                'stroke-width': 1,\n                stroke: '#CED5D4'\n                // 'input-shadow-fill': '#000000',\n                // 'input-shadow-opacity': 0.35,\n              }\n            },\n            text: {\n              style: {\n                'font-family': '\"Lucida Grande\", sans-serif',\n                'font-size': '13px',\n                fill: '#4B4B4B'\n              }\n            },\n            states: {\n              selected: {\n                className: 'date-range-chooser-state-selected',\n                container: {\n                  style: {\n                    fill: '#FFFFFF',\n                    stroke: '#1E1F1F'\n                  }\n                }\n              },\n              errored: {\n                className: 'date-range-chooser-state-errored',\n                container: {\n                  style: {\n                    fill: '#FFFFFF',\n                    stroke: '#D25353'\n                  }\n                }\n                // 'input-error-tooltip-font-color': '#FF0000'\n              }\n            }\n          },\n          label: {\n            className: 'date-range-chooser-label',\n            text: {\n              style: {\n                'font-family': '\"Lucida Grande\", sans-serif',\n                'font-size': '13px',\n                fill: '#4B4B4B'\n              }\n            }\n          }\n        };\n      config.disabled = extData.disabled || false;\n      config.layout = extData.layout || 'inline';\n      config.orientation = extData.orientation || 'horizontal';\n      config.position = extData.position || 'top';\n      config.alignment = extData.alignment || 'right';\n      config.dateFormat = extData.dateFormat || '%d-%m-%Y';\n      config.fromText = extData.fromText || 'From:';\n      config.fromTooltipText = extData.fromTooltipText || 'From Date';\n      config.toText = extData.toText || 'To:';\n      config.toTooltipText = extData.toTooltipText || 'To Date';\n      config.styles = Object.assign(defaultStyles, extData.styles);\n      return config;\n    }\n\n    createErrorGroup (symbol) {\n      // return;\n    //   let self = this,\n    //     paper = self.graphics.paper,\n    //     circle,\n    //     crossPath,\n    //     cross,\n    //     rect,\n    //     text,\n    //     group,\n    //     textBBox,\n    //     circleBBox,\n    //     rectBBox,\n    //     symbolBBox,\n    //     orientation = self.config.orientation,\n    //     position = self.config.position;\n\n    //   if (orientation === 'horizontal') {\n    //     if (position === 'top') {\n    //       symbolBBox = symbol.getBoundElement().getBBox();\n    //       group = paper.group('error-group');\n\n    //       rect = paper.rect(symbolBBox.x,\n    //         symbolBBox.y - symbolBBox.height, 20, 20, group);\n    //       rectBBox = rect.getBBox();\n\n    //       circle = paper.circle(rectBBox.x + 5 + 1,\n    //         rectBBox.y + 6 + 4, 6, group);\n    //       circleBBox = circle.getBBox();\n\n    //       crossPath = this.getCrossPath(circleBBox, 4);\n    //       cross = paper.path(crossPath, group);\n\n    //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //         '', group);\n    //       textBBox = text.getBBox();\n    //     } else if (position === 'bottom') {\n    //       symbolBBox = symbol.getBoundElement().getBBox();\n    //       group = paper.group('error-group');\n\n    //       rect = paper.rect(symbolBBox.x,\n    //         symbolBBox.y + symbolBBox.height, 20, 20, group);\n    //       rectBBox = rect.getBBox();\n\n    //       circle = paper.circle(rectBBox.x + 5 + 1,\n    //         rectBBox.y + 6 + 4, 6, group);\n    //       circleBBox = circle.getBBox();\n\n    //       crossPath = this.getCrossPath(circleBBox, 4);\n    //       cross = paper.path(crossPath, group);\n\n    //       text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //         '', group);\n    //       textBBox = text.getBBox();\n    //     }\n    //   } else if (orientation === 'vertical') {\n    //     symbolBBox = symbol.getBoundElement().getBBox();\n    //     group = paper.group('error-group');\n\n    //     rect = paper.rect(symbolBBox.x,\n    //       symbolBBox.y + symbolBBox.height, 20, 20, group);\n    //     rectBBox = rect.getBBox();\n\n    //     circle = paper.circle(rectBBox.x + 5 + 1,\n    //       rectBBox.y + 6 + 4, 6, group);\n    //     circleBBox = circle.getBBox();\n\n    //     crossPath = this.getCrossPath(circleBBox, 4);\n    //     cross = paper.path(crossPath, group);\n\n    //     text = paper.text(circleBBox.x + circleBBox.width + 4, rectBBox.y + 2,\n    //       '', group);\n    //     textBBox = text.getBBox();\n    //   }\n\n    //   circle.attr({\n    //     'stroke': '#d71f26',\n    //     'stroke-width': '1',\n    //     'fill': 'none'\n    //   });\n    //   cross.attr({\n    //     'stroke': '#000000',\n    //     'stroke-width': '1.5'\n    //   });\n    //   text.attr({\n    //     'text-anchor': 'start',\n    //     'y': textBBox.y + textBBox.height,\n    //     'fill': '#D80000',\n    //     'font-family': '\"Lucida Grande\", sans-serif',\n    //     'font-size': '12'\n    //   });\n    //   rect.attr({\n    //     'fill': '#FFFFFF',\n    //     'fill-opacity': '0.8',\n    //     'stroke-width': '0',\n    //     'width': textBBox.width + circleBBox.width\n    //   });\n    //   group.attr({\n    //     visibility: 'hidden'\n    //   });\n\n    //   return {\n    //     'group': group,\n    //     'cross': cross,\n    //     'circle': circle,\n    //     'rect': rect,\n    //     'text': text\n    //   };\n    // }\n\n    // getCrossPath (circleBox, padding) {\n    //   // M478,77L483,82M478,82L483,77\n    //   let circleX1 = Math.round(circleBox.x),\n    //     circleY1 = Math.round(circleBox.y),\n    //     circleX2 = Math.round(circleBox.x2),\n    //     circleY2 = Math.round(circleBox.y2),\n    //     crossX1 = circleX1 + 4,\n    //     crossY1 = circleY1 + 2,\n    //     crossX2 = circleX2 - 4,\n    //     crossY2 = circleY2 - 3,\n    //     pathStr = 'M' + crossX1 + ',' + crossY1 + 'L' + crossX2 + ',' + crossY2;\n    //   pathStr += 'M' + crossX1 + ',' + crossY2 + 'L' + crossX2 + ',' + crossY1;\n    //   return pathStr;\n    }\n\n    setErrorMsg (errorGroup, errorMsg) {\n      // return;\n      // let errorRectX,\n      //   errorRectWidth,\n      //   errorRectEnd;\n\n      // if (errorGroup.text.attr('text') === errorMsg) {\n      //   return;\n      // }\n      // errorGroup.text.attr('text', errorMsg);\n      // errorGroup.rect.attr('width',\n      //   errorGroup.text.getBBox().width + (4 * 2) + errorGroup.circle.getBBox().width + 2);\n\n      // errorRectX = errorGroup.rect.getBBox().x;\n      // errorRectWidth = errorGroup.rect.getBBox().width;\n      // errorRectEnd = errorRectX + errorRectWidth;\n      // console.log(errorRectEnd, this.containerRight);\n      // if (errorRectEnd > this.containerRight) {\n      //   let diff = errorRectEnd - this.containerRight;\n      //   errorGroup.rect.attr('x', errorRectX - diff);\n      //   errorGroup.circle.attr('cx', errorGroup.circle.getBBox().x - diff + 5);\n      //   errorGroup.cross.translate(-diff - 1, 0);\n      //   errorGroup.text.attr('x', errorGroup.text.getBBox().x - diff);\n      // }\n    }\n\n    createObjectAssign () {\n      if (typeof Object.assign !== 'function') {\n        Object.assign = function (target, varArgs) {\n          'use strict';\n          if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n          }\n\n          var to = Object(target);\n\n          for (let index = 1; index < arguments.length; index++) {\n            let nextSource = arguments[index];\n\n            if (nextSource != null) {\n              for (let nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                  to[nextKey] = nextSource[nextKey];\n                }\n              }\n            }\n          }\n          return to;\n        };\n      }\n    }\n\n    /**\n     * Fusioncharts life cycle method for extension\n     */\n    init (require) {\n      var instance = this;\n      require([\n        'xAxis',\n        'graphics',\n        'chart',\n        'dataset',\n        'globalReactiveModel',\n        'spaceManagerInstance',\n        'extData',\n        'smartLabel',\n        'chartInstance',\n        function (\n          xAxis,\n          graphics,\n          chart,\n          dataset,\n          globalReactiveModel,\n          spaceManagerInstance,\n          extData,\n          smartLabel,\n          chartInstance) {\n          instance.xAxis = xAxis;\n          instance.graphics = graphics;\n          instance.chart = chart;\n          instance.dataset = dataset;\n          instance.globalReactiveModel = globalReactiveModel;\n          instance.spaceManagerInstance = spaceManagerInstance;\n          instance.config = instance.createConfig(extData);\n          instance.smartLabel = smartLabel;\n          instance.chartInstance = chartInstance;\n        }\n      ]);\n      instance.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];\n      instance.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];\n      instance.toolbars = [];\n      instance.measurement = {};\n      instance.toolbars.push(instance.createToolbar());\n      return instance;\n    };\n\n    createToolbar () {\n      var toolbar,\n        self = this,\n        fromDateLabel,\n        toDateLabel,\n        fromGroup,\n        toGroup,\n        fromFormattedDate,\n        toFormattedDate,\n        styles = this.config.styles,\n        inputBtnStyles = styles.inputButton,\n        paper = this.graphics.paper,\n        classNames,\n        addCssRules = function (classNames, styles) {\n          var key, className;\n          for (key in classNames) {\n            className = classNames[key];\n            switch (key) {\n              case 'container':\n                styles.container && paper.cssAddRule('.' + className, styles.container.style);\n                break;\n              case 'input':\n                styles.text && paper.cssAddRule('.' + className, {\n                  color: styles.text.style.fill,\n                  'font-family': styles.text.style['font-family'],\n                  'font-size': styles.text.style['font-size']\n                });\n                break;\n              case 'text':\n                styles.text && paper.cssAddRule('.' + className, styles.text.style);\n            }\n          }\n        },\n        createInputButtons = function (store) {\n          var key, inputButton, text, config, states, state;\n\n          for (key in store) {\n            inputButton = store[key];\n            text = inputButton.text;\n            config = inputButton.config;\n            self[key] = d3.inputButton(text).setConfig(config);\n            self[key].namespace('fusioncharts');\n            self[key].appendSelector('daterange');\n            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), inputBtnStyles);\n            states = config.states;\n            for (state in states) {\n              addCssRules(self[key].getIndividualClassNames(self[key].config.states[state]),\n                inputBtnStyles.states[state]);\n            }\n\n            self[key].attachEventHandlers(inputButton.eventListeners);\n            inputButton.group.addSymbol(self[key]);\n          }\n        },\n        createLabels = function (store) {\n          var key, label, text, config;\n\n          for (key in store) {\n            label = store[key];\n            text = label.text;\n            config = label.config;\n            self[key] = new self.toolbox.Label(text, dependencies, config);\n            // self[key].namespace('fusioncharts');\n            // self[key].appendSelector('daterange');\n            addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), label.styles);\n            label.group.addSymbol(self[key]);\n          }\n        },\n        dependencies = {\n          paper: this.graphics.paper,\n          chart: this.chart,\n          smartLabel: this.smartLabel,\n          chartContainer: this.graphics.container\n        },\n        fromDateEventConfig = {\n          click: function () {\n              // if (self.fromDate.state === 'errored' &&\n              //   self.fromError.text.attr('text') !== '') {\n              //   self.toError.group.hide();\n              //   self.fromError.group.show();\n              // }\n              self.fromDate.setState('selected');\n          },\n          // tooltext: self.config.fromTooltipText,\n          keypress: (e) => {\n            let event = e || window.event,\n              charCode = event.which || event.keyCode;\n            if (charCode === 13) {\n              self.startDate = self.fromDate.text();\n              if (self.fromDate.state !== 'errored') {\n                self.fromDate.blur();\n                // self.fromError.group.hide();\n                // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n                // self.fromDate.removeState('selected');\n                // self.fromDate.removeState('errored');\n              } else {\n                // self.fromError.group.show();\n                // self.fromDate.state = 'errored';\n                // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n              }\n            }\n          },\n          blur: function () {\n            self.startDate = self.fromDate.text();\n            if (self.fromDate.state !== 'errored') {\n              self.fromDate.blur();\n              // self.fromError.group.hide();\n              // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n              self.fromDate.removeState('selected');\n            } else {\n              // self.fromError.group.show();\n              // self.fromDate.svgElems.node.tooltip(self.startTooltipErrorMsg);\n            }\n          }\n        },\n        toDateEventConfig = {\n          click: function () {\n              // if (self.toDate.state === 'errored' &&\n              //   self.toError.text.attr('text') !== '') {\n              //   self.fromError.group.hide();\n              //   self.toError.group.show();\n              // }\n              // self.toDate.edit();\n              self.toDate.setState('selected');\n          },\n          // tooltext: self.config.toTooltipText,\n          keypress: (e) => {\n            let event = e || window.event,\n              charCode = event.which || event.keyCode;\n            if (charCode === 13) {\n              self.endDate = self.toDate.text();\n              if (self.toDate.state !== 'errored') {\n                self.toDate.blur();\n                // self.toError.group.hide();\n                // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n                self.toDate.removeState('selected');\n              } else {\n                // self.toError.group.show();\n                // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n              }\n            }\n          },\n          blur: function () {\n            // self.toDate.blur();\n            self.endDate = self.toDate.text();\n            if (self.toDate.state !== 'errored') {\n              // self.toDate.blur();\n              // self.toError.group.hide();\n              // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n              self.toDate.removeState('selected');\n            } else {\n              // self.toError.group.show();\n              // self.toDate.svgElems.node.tooltip(self.endTooltipErrorMsg);\n            }\n          }\n        },\n        labelList,\n        inputButtonlist;\n\n      self.fromDate = {};\n      self.toDate = {};\n\n      fromFormattedDate = this.getDate(this.startDt);\n      toFormattedDate = this.getDate(this.endDt);\n      toolbar = new this.HorizontalToolbar(dependencies);\n\n      fromGroup = new this.toolbox.ComponentGroup(dependencies);\n\n      toGroup = new this.toolbox.ComponentGroup(dependencies);\n\n      labelList = {\n        fromDateLabel: {\n          text: this.config['fromText'],\n          config: {\n            className: styles.label.className,\n            container: {\n              'width': 40\n            }\n          },\n          styles: styles.label,\n          group: fromGroup\n        },\n        toDateLabel: {\n          text: this.config['toText'],\n          config: {\n            className: styles.label.className,\n            container: {\n              'width': 40\n            }\n          },\n          styles: styles.label,\n          group: toGroup\n        }\n      };\n\n      inputButtonlist = {\n        fromDate: {\n          text: fromFormattedDate,\n          config: {\n            width: inputBtnStyles.width,\n            height: inputBtnStyles.height,\n            padding: inputBtnStyles.padding,\n            radius: inputBtnStyles.radius,\n            className: inputBtnStyles.className,\n            states: {\n              selected: inputBtnStyles.states.selected.className,\n              errored: inputBtnStyles.states.errored.className\n            }\n          },\n          eventListeners: fromDateEventConfig,\n          group: fromGroup\n        },\n        toDate: {\n          text: toFormattedDate,\n          config: {\n            width: inputBtnStyles.width,\n            height: inputBtnStyles.height,\n            padding: inputBtnStyles.padding,\n            radius: inputBtnStyles.radius,\n            className: inputBtnStyles.className,\n            states: {\n              selected: inputBtnStyles.states.selected.className,\n              errored: inputBtnStyles.states.errored.className\n            }\n          },\n          eventListeners: toDateEventConfig,\n          group: toGroup\n        }\n      };\n\n\n      createLabels(labelList);\n      createInputButtons(inputButtonlist);\n\n      toolbar.addComponent(fromGroup);\n      toolbar.addComponent(toGroup);\n      return toolbar;\n    };\n\n    getLogicalSpace (availableWidth, availableHeight) {\n      var logicalSpace = this.toolbars[0].getLogicalSpace(availableWidth, availableHeight);\n      this.toolbars[0].width = logicalSpace.width;\n      this.toolbars[0].height = logicalSpace.height;\n      return {\n        width: logicalSpace.width,\n        height: logicalSpace.height\n      };\n    };\n\n    placeInCanvas () {\n      var self = this;\n      self.spaceManagerInstance.add([{\n        name: function () {\n          return 'DateRangeChooserToolbox';\n        },\n        ref: function (obj) {\n          return obj['0'];\n        },\n        self: function () {\n          return self;\n        },\n        priority: function () {\n          return 2;\n        },\n        layout: function (obj) {\n          return obj[self.config.layout];\n        },\n        orientation: [{\n          type: function (obj) {\n            return obj[self.config.orientation];\n          },\n          position: [{\n            type: function (obj) {\n              return obj[self.config.position];\n            },\n            alignment: [{\n              type: function (obj) {\n                return obj[self.config.alignment];\n              },\n              dimensions: [function () {\n                var parent = this.getParentComponentGroup();\n                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());\n              }]\n            }]\n          }]\n        }]\n      }]);\n    };\n\n    setDrawingConfiguration (x, y, width, height, group) {\n      var mes = this.measurement;\n      mes.x = x;\n      mes.y = y;\n      mes.width = width;\n      mes.height = height;\n\n      this.parentGroup = group;\n\n      return this;\n    };\n\n    draw (x, y, width, height, group) {\n      let self = this,\n        measurement = self.measurement,\n        toolbars = self.toolbars,\n        ln,\n        i,\n        toolbar,\n        model = self.globalReactiveModel;\n\n      x = x === undefined ? measurement.x : x;\n      y = y === undefined ? measurement.y : y;\n      width = width === undefined ? measurement.width : width;\n      height = height === undefined ? measurement.height : height;\n      group = group === undefined ? self.parentGroup : group;\n      if (width && height) {\n        self.isDrawn = true;\n        for (i = 0, ln = toolbars.length; i < ln; i++) {\n          toolbar = toolbars[i];\n          toolbar.draw(x, y, group);\n        }\n        model.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'],\n          (start, end) => {\n            // setTimeout(() => {\n            self.startDt = start[1];\n            self.fromDate.text(self.getDate(start[1]));\n            // self.fromDate.blur(self.getDate(start[1]));\n            // self.fromError.text.attr('text', '');\n            // self.fromError.group.hide();\n            // self.fromDate.svgElems.node.tooltip(self.config.fromTooltipText);\n            self.fromDate.removeState('selected');\n            self.fromDate.removeState('errored');\n            self.endDt = end[1];\n            self.toDate.text(self.getDate(end[1]));\n            // self.toDate.blur(self.getDate(end[1]));\n            // self.toError.text.attr('text', '');\n            // self.toError.group.hide();\n            // self.toDate.svgElems.node.tooltip(self.config.toTooltipText);\n            self.toDate.removeState('selected');\n            self.toDate.removeState('errored');\n            // }, 400);\n          }\n        );\n      }\n\n      if (self.config.orientation === 'vertical') {\n        self.fromError = self.createErrorGroup(self.toDate);\n        self.toError = self.createErrorGroup(self.toDate);\n      } else if (self.config.orientation === 'horizontal') {\n        self.fromError = self.createErrorGroup(self.fromDate);\n        self.toError = self.createErrorGroup(self.toDate);\n      }\n      self.startDataset = self.globalReactiveModel.model['x-axis-absolute-range-start'];\n      self.endDataset = self.globalReactiveModel.model['x-axis-absolute-range-end'];\n      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n      self.maxXAxisTicks = self.globalReactiveModel.model['x-axis-maximum-allowed-ticks'];\n      self.minDatestampDiff = self.globalReactiveModel.model['minimum-consecutive-datestamp-diff'];\n      self.minActiveInterval = self.maxXAxisTicks * self.minDatestampDiff;\n      self.containerRight = self.graphics.container.clientLeft + self.graphics.container.clientWidth;\n      self.containerBottom = self.graphics.container.clientTop + self.graphics.container.clientHeight;\n    };\n  }\n  return DateRange;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/fcts-ext-daterange.js"],"sourceRoot":""}